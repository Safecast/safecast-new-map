<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Set metadata and link CSS -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{translate "title"}}</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/static/leaflet.css">
    <link rel="stylesheet" href="/static/nouislider.min.css">

		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="180x180" href="/static/images/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/static/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/static/images/favicon-16x16.png">
		<link rel="manifest" href="/static/images/site.webmanifest">


    <style>
/* General styles */
body, html {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden; /* Hide scrollbars */
  background: var(--modal-bg); /* Apply theme background color */
  color: var(--modal-text); /* Ensure text inherits theme color */
  font-family: var(--font-family-base); /* Keep text styling consistent across the UI */
  font-size: var(--font-size-base); /* Align base size so similar widgets match */
  line-height: 1.5; /* Provide comfortable reading in both themes */
}

        /* Color and typography variables adapt to system theme */
        :root {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 0px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          --info-card-bg: rgba(255, 255, 255, 0.9);
          --info-card-border: 1px solid rgba(0, 0, 0, 0.08);
          --api-method-bg: rgba(0, 123, 255, 0.1);
          --api-method-text: #0056b3;
          --isotope-highlight: #FF6B00; /* Orange for light mode - better contrast */
          color-scheme: light; /* Default to light scheme */
          --font-family-base: "Segoe UI", "Noto Sans", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif; /* Shared font stack keeps every control aligned */
          --font-size-base: 12px; /* Main text size for buttons, menus, and labels */
          --font-size-sm: 10px; /* Secondary text such as helper descriptions */
					--font-size-xxs: 6px;
          --font-size-xs: 8px; /* Compact labels and metadata */
          --font-size-lg: 14px; /* Slightly larger controls where extra emphasis helps */
          --font-size-xl: 20px; /* Section headings */
          --font-size-display: 28px; /* Prominent readings inside tooltips */
        }

        @media (prefers-color-scheme: dark) {
          :root {
            --overlay-bg: rgba(0, 0, 0, 0.85);
            --progress-bg: #1a1a1a;
            --progress-color: #ffffff;
            --progress-bar-bg: #666666;
            --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            --upload-btn-bg: #4caf50; /* Standard site green for consistency */
            --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
            --control-bg: rgba(30, 30, 30, 0.9);
            --control-bg-hover: rgba(40, 40, 40, 0.95);
            --legend-border: 1px solid #666;
            --modal-bg: #1a1a1a;
            --modal-text: #ffffff;
            --modal-border: 1px solid #666;
            --link-color: #64b5f6;
            --info-card-bg: rgba(26, 26, 26, 0.95);
            --info-card-border: 1px solid rgba(255, 255, 255, 0.2);
            --api-method-bg: rgba(100, 181, 246, 0.25);
            --api-method-text: #64b5f6;
            --isotope-highlight: #FFD700; /* Gold for dark mode */
            color-scheme: dark; /* Match system dark scheme */
          }
        }

        /* Reuse the same typography across controls so menus, buttons, and overlays match */
        body, html, button, input, select, textarea {
          font-family: var(--font-family-base);
        }

        button,
        .upload-btn,
        .locate-btn,
        .back-to-all-btn,
        .slider-reset-btn,
        .slider-toggle button,
        .qr-btn,
        .live-modal-close {
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
        }

        /* Align shared UI chrome sizes while letting specialized components override when needed */
        .slider-label,
        .slider-toggle button,
        .live-popup-meta,
        .live-popup-small-link {
          font-size: var(--font-size-xs);
        }

        .live-tooltip-desc,
        .live-popup-dose-secondary,
        .live-popup-dose-status,
        .live-chart-unit {
          font-size: var(--font-size-sm);
        }

        .leaflet-container,
				.leaflet-container .leaflet-control,
        .leaflet-container .leaflet-popup,
        .leaflet-container .leaflet-tooltip {
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
        }

				/* Base style ‚Äì applies to all phones (old and new) */
				.leaflet-container .leaflet-control-attribution {
					font-family: var(--font-family-base);
					font-size: var(--font-size-xxs);
				}

				/* Increase font size only on screens wider than 768px (tablets, laptops, desktops) */
				@media (min-width: 768px) {
					.leaflet-container .leaflet-control-attribution {
						font-size: var(--font-size-xs);
					}
				}

        /* Manual theme overrides */
        :root[data-theme='light'] {
          --overlay-bg: rgba(255, 255, 255, 0.7);
          --progress-bg: #ffffff;
          --progress-color: #333333;
          --progress-bar-bg: #f4f4f4;
          --progress-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(255, 255, 255, 0.25);
          --control-bg-hover: rgba(255, 255, 255, 0.35);
          --legend-border: 0px solid #ccc;
          --modal-bg: #ffffff;
          --modal-text: #333333;
          --modal-border: 1px solid #888;
          --link-color: #007bff;
          --info-card-bg: rgba(255, 255, 255, 0.9);
          --info-card-border: 1px solid rgba(0, 0, 0, 0.08);
          --api-method-bg: rgba(0, 123, 255, 0.1);
          --api-method-text: #0056b3;
          --isotope-highlight: #FF6B00; /* Orange for light mode - better contrast */
          color-scheme: light; /* Force light scheme when manually selected */
        }

        :root[data-theme='dark'] {
          --overlay-bg: rgba(0, 0, 0, 0.85);
          --progress-bg: #1a1a1a;
          --progress-color: #ffffff;
          --progress-bar-bg: #666666;
          --progress-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
          --upload-btn-bg: #4caf50; /* Standard site green for consistency */
          --upload-btn-bg-hover: #388e3c; /* Slightly darker on hover */
          --control-bg: rgba(30, 30, 30, 0.9);
          --control-bg-hover: rgba(40, 40, 40, 0.95);
          --legend-border: 1px solid #666;
          --modal-bg: #1a1a1a;
          --modal-text: #ffffff;
          --modal-border: 1px solid #666;
          --link-color: #64b5f6;
          --info-card-bg: rgba(26, 26, 26, 0.95);
          --info-card-border: 1px solid rgba(255, 255, 255, 0.2);
          --api-method-bg: rgba(100, 181, 246, 0.25);
          --api-method-text: #64b5f6;
          --isotope-highlight: #FFD700; /* Gold for dark mode */
          color-scheme: dark; /* Force dark scheme when manually selected */
        }

        /* Brighten map tiles in dark mode to improve readability */
        :root[data-theme='dark'] .leaflet-tile-pane {
           filter: brightness(1.5) contrast(0.85);
        }

        @media (prefers-color-scheme: dark) {
          .leaflet-tile-pane {
            filter: brightness(1.5) contrast(0.85);
          }
        }
        
        /* Ensure filter is removed if forcibly switched to light mode */
        :root[data-theme='light'] .leaflet-tile-pane {
           filter: brightness(0.95) contrast(0.7);
        }

        @media (prefers-color-scheme: light) {
          .leaflet-tile-pane {
             /* Subtle darkening for light mode */
             filter: brightness(0.95) contrast(0.7);
          }
        }

        /* Theme toggle switch */
        #themeToggle {
          position: absolute;
          bottom: 20px;
          right: 10px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
          padding: 4px 6px;
          z-index: 1000;
          font-family: var(--font-family-base);
          font-size: var(--font-size-base);
          display: flex;
          align-items: center;
          gap: 6px;
          color: var(--modal-text);
        }

        /* Small centered pill that surfaces the shareable short link */
        #shortLinkDisplay {
          position: absolute;
          top: 12px;
          left: 50%;
          transform: translateX(-50%);
          background: var(--overlay-bg);
          border: var(--legend-border);
          border-radius: 999px;
          padding: 4px 10px;
          font-size: var(--font-size-xs);
          color: var(--modal-text);
          opacity: 0.75;
          z-index: 1200;
          cursor: pointer;
          display: none;
          user-select: none;
          transition: opacity 0.2s ease;
        }

        #shortLinkDisplay:hover,
        #shortLinkDisplay:focus,
        #shortLinkDisplay.copied {
          opacity: 1;
          outline: none;
        }

        #shortLinkDisplay.copied {
          background: var(--control-bg-hover);
        }

        /* API quickstart cards inside the info modal stay theme aware through shared variables. */
        #infoModal .api-heading {
          font-size: var(--font-size-xl);
          margin: 0 0 0.5em;
        }

        #infoModal .api-intro {
          margin: 0 0 0.75em;
        }

        #infoModal .api-note {
          margin: 0 0 1.25em;
          font-size: var(--font-size-sm);
          opacity: 0.75;
        }

        #infoModal .api-grid {
          display: grid;
          gap: 12px;
        }

        @media (min-width: 640px) {
          #infoModal .api-grid {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
          }
        }

        #infoModal .api-card {
          background: var(--info-card-bg);
          border: var(--info-card-border);
          border-radius: 10px;
          padding: 12px 14px;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        #infoModal .api-card-head {
          display: flex;
          align-items: baseline;
          gap: 8px;
          margin-bottom: 8px;
        }

        #infoModal .api-method {
          display: inline-flex;
          align-items: center;
          padding: 2px 8px;
          border-radius: 999px;
          background: var(--api-method-bg);
          color: var(--api-method-text);
          font-size: var(--font-size-xs);
          font-weight: 700;
          letter-spacing: 0.06em;
        }

        #infoModal .api-path {
          font-family: var(--font-family-base);
          font-size: var(--font-size-sm);
          opacity: 0.8;
        }

        #infoModal .api-card-title {
          margin: 0 0 6px;
          font-size: var(--font-size-lg);
        }

        #infoModal .api-card-desc {
          margin: 0 0 10px;
          font-size: var(--font-size-sm);
        }

        #infoModal .api-card-link {
          display: inline-block;
          margin-bottom: 6px;
          color: var(--link-color);
          font-weight: 600;
          text-decoration: none;
        }

        #infoModal .api-card-link:hover,
        #infoModal .api-card-link:focus {
          text-decoration: underline;
        }

        #infoModal .api-card-note {
          margin: 0;
          font-size: var(--font-size-xs);
          opacity: 0.75;
        }

        #infoModal .api-more {
          margin-top: 16px;
          font-size: var(--font-size-sm);
        }

        .theme-icon {
          font-size: var(--font-size-base);
          line-height: 1;
        }

        .theme-switch {
          position: relative;
          display: inline-block;
          width: 30px;
          height: 16px;
          margin: 0 4px;
        }

        .theme-switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .theme-slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: 0.2s;
          border-radius: 16px;
        }

        .theme-slider:before {
          position: absolute;
          content: "";
          height: 12px;
          width: 12px;
          left: 2px;
          bottom: 2px;
          background-color: #fff;
          transition: 0.2s;
          border-radius: 50%;
        }

        .theme-switch input:checked + .theme-slider {
          background-color: #2196F3;
        }

        .theme-switch input:checked + .theme-slider:before {
          transform: translateX(14px);
        }

        /* Map container */
        #map {
          height: 100vh; /* Map takes full viewport height */
          margin: 0;
          overflow: hidden;
        }

        /* Custom tooltip styles */
        .custom-tooltip {
          /* Match tooltip with current theme */
          background-color: var(--modal-bg);
          border-radius: 5px;
          padding: 10px;
          color: var(--modal-text);
          box-shadow: 0px 0px 3px rgba(0,0,0,0.3);
        }

        /* Consistent hover/focus hints for interactive controls */
        .control-tooltip {
          position: fixed;
          z-index: 1400;
          pointer-events: none;
          background: var(--modal-bg);
          color: var(--modal-text);
          border: var(--legend-border);
          border-radius: 8px;
          padding: 10px 12px;
          box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
          font-size: var(--font-size-sm);
          line-height: 1.4;
          max-width: 280px;
          opacity: 0;
          transform: scale(0.96);
          transform-origin: center;
          transition: opacity 120ms ease, transform 120ms ease;
          text-align: left;
        }

        .control-tooltip--visible {
          opacity: 1;
          transform: scale(1);
        }

        .control-tooltip__title {
          font-weight: 600;
          margin-bottom: 4px;
          font-size: var(--font-size-base);
        }

        .control-tooltip__meta {
          font-size: var(--font-size-xs);
          opacity: 0.75;
          margin-top: 6px;
        }

        /* Lightweight list styling keeps multi-line tooltip content readable without extra markup. */
        .control-tooltip__list {
          margin: 6px 0 0;
          padding-left: 16px;
        }

        .control-tooltip__list li {
          margin-bottom: 4px;
        }

        .control-tooltip__list li:last-child {
          margin-bottom: 0;
        }

        /* Link inside popups pointing to full legend */
        .risk-link {
          color: var(--link-color);
          text-decoration: underline;
        }

        /* Larger color squares for legend items */
        .legend-square {
          display: inline-block;
          width: 12px;
          height: 12px;
          margin-right: 6px;
          border: var(--legend-border);
          border-radius: 2px;
        }

        /* Container for upload button */
        .upload-btn-container {
          position: absolute;
          top: 20px;
          right: 20px;
          z-index: 1000;
        }

        /* Upload button styling, theme-aware */
        .upload-btn {
          background-color: var(--upload-btn-bg); /* Use site green for familiarity */
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: #ffffff; /* White text stays readable across themes */
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }

        /* File upload overlay */
        #fileOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: var(--overlay-bg);
          z-index: 10000;
          display: flex;
          justify-content: center;
          align-items: center;
        }

        /* Upload progress container */
        #fileProgressContainer {
          background-color: var(--progress-bg);
          color: var(--progress-color);
          padding: 20px;
          border-radius: 10px;
          max-width: 600px;
          width: 100%;
          box-shadow: var(--progress-shadow);
          max-height: 80vh;
          overflow-y: auto; /* Allow scrolling for many uploads */
        }

        /* Individual file upload progress */
        .file-progress {
          margin-bottom: 15px;
        }

        .file-name {
          font-weight: bold;
          margin-bottom: 5px;
        }

        /* Progress bar */
        .progress-bar {
          width: 100%;
          height: 10px;
          background-color: var(--progress-bar-bg);
          border-radius: 5px;
          overflow: hidden;
        }

        .progress-bar-inner {
          height: 100%;
          background-color: #4caf50;
          width: 0%;
        }

        /* Server processing indicator */
        .server-processing {
          margin-left: 10px;
          font-size: var(--font-size-base);
          color: #ff9800;
        }

        /* Upload button hover effect */
        .upload-btn:hover {
          background-color: var(--upload-btn-bg-hover); /* Darker shade on hover */
        }

        /* Container for geolocation button */
        .locate-btn-container {
          position: absolute;
          top: 60px;
          right: 20px;
          z-index: 1000;
        }

        /* Geolocation button styling, theme-aware */
        .locate-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
          display: flex;
          align-items: center;
          justify-content: center;
        }

        /* Geolocation button hover effect */
        .locate-btn:hover {
          background-color: var(--control-bg-hover);
        }

        /* GitHub link styling */
        .github-link {
          position: absolute;
          bottom: 20px;
          left: 20px;
          z-index: 1000;
        }

        .github-icon {
          width: 60px;
          height: 60px;
          opacity: 0.7;
        }

        .github-icon:hover {
          opacity: 1;
        }

        /* Program info uses theme text and link colors */
        .program-info {
          position: absolute;
          bottom: 20px;
          left: 70px;
          z-index: 1000;
          color: var(--modal-text);
          font-size: var(--font-size-base);
          opacity: 0.6;
        }

        .program-info a {
          color: var(--link-color);
          text-decoration: none;
        }

        .program-info a:hover {
          text-decoration: underline;
        }

        .program-info:hover {
          opacity: 1;
        }

        /* "Back to all tracks" button container.
           Positioned below the QR button to prevent overlap. */
        .back-to-all-container {
          position: absolute;
          top: 185px; /* place under geolocation+QR stack */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .back-to-all-btn {
          background-color: #2196F3;
          background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
          border: 2px solid #1976D2;
          border-radius: 6px;
          padding: 8px 16px;
          cursor: pointer;
          font-size: var(--font-size-base);
          font-weight: 600;
          color: #ffffff;
          box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4), 0 1px 3px rgba(0,0,0,0.3);
          transition: all 0.2s ease;
        }

        .back-to-all-btn:hover {
          background: linear-gradient(135deg, #1E88E5 0%, #1565C0 100%);
          box-shadow: 0 4px 12px rgba(33, 150, 243, 0.6), 0 2px 4px rgba(0,0,0,0.4);
          transform: translateY(-1px);
        }

        /* Dedicated download container lives under the back button so
           track view controls remain grouped for quick access. */
        .download-track-container {
          position: absolute;
          top: 225px; /* keep consistent spacing below the back button */
          right: 20px;
          z-index: 1000;
          display: none;
        }

        .download-track-btn {
          background-color: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          padding: 5px 10px;
          cursor: pointer;
          font-size: var(--font-size-base);
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
          text-decoration: none;
          display: inline-block;
        }

        .download-track-btn:hover {
          background-color: var(--control-bg-hover);
        }


        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äì‚Äì Slider clean-look patch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .date-slider-box {
          padding: 6px;
          width: 50px;
        }

        /* 0) Basic slider container geometry: buffer = 8px
           (half handle size) so handles never exceed the rail */
        #dateSlider{
          width:6px;                 /* rail thickness */
          height:130px;              /* actual track length */
          padding:0px 0;             /* inner top/bottom padding */
          box-sizing:content-box;    /* ensures padding works */
          margin:16px auto 26px;
        }

        /* 1) grey slider rail */
        #dateSlider .noUi-base{
          background:#bfbfbf;
          width:100%;                /* 6px width */
          height:100%;               /* 130px minus padding */
        }

        /* 2) colored section only between handles */
        #dateSlider .noUi-connect{
          background:#1e88e5;        /* pick your brand color */
        }

        /* Slider handles respect theme colors */
        .noUi-vertical .noUi-handle{
          width:32px;
          height:20px;
          left:-18px;              /* center on 6px rail */
          border-radius:3px;
          background: var(--control-bg);      /* follow theme */
          border: var(--legend-border);   /* match theme border */
          box-shadow:0 1px 3px rgba(0,0,0,.25);
          cursor:grab;
        }
        /* 4) remove pseudo-element tails */
        .noUi-handle:before,
        .noUi-handle:after{ display:none; }

        .slider-label{
          margin:2px 0;
          font-size: var(--font-size-xs);
          line-height:1.15em;
          white-space:nowrap;
          text-align:center;
        }

        /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Year / Month toggle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        .slider-toggle{
          display:flex; gap:2px; margin:2px 0 4px;
          font-size: var(--font-size-xs); line-height:1; user-select:none;
        }
        /* Year/Month toggle buttons adapt to theme */
        .slider-toggle button{
          flex:1 1 0; padding:2px 4px;
          border: var(--legend-border); background: var(--control-bg);
          border-radius:3px; cursor:pointer;
          color: var(--modal-text);
        }
        .slider-toggle button.active{
          background:#1e88e5; color:#fff; border-color:#1e88e5;
        }

        /* ‚îÄ‚îÄ‚îÄ Year mode: slider height matches month slider ‚îÄ‚îÄ‚îÄ */
        #yearSlider{
          /* copied parameters from #dateSlider */
          width:6px;                 /* rail thickness */
          height:130px;              /* track length */
          padding:0;                 /* inner padding */
          margin:16px auto 26px;     /* same margins */
          box-sizing:content-box;
        }
        /* grey rail and blue connect bar */
        #yearSlider .noUi-base      {background:#bfbfbf;width:100%;height:100%;}
        #yearSlider .noUi-connect   {background:#bfbfbf;}


        /* Reset button styled with theme variables */
        .slider-reset-btn{
          display:block;
          width:100%;
          margin-top:4px;
          padding:2px 4px;
          font-size: var(--font-size-xl);
          border: var(--legend-border);
          background: var(--control-bg);
          border-radius:3px;
          cursor:pointer;
          color: var(--modal-text);
        }
        .slider-reset-btn:hover{ background: var(--control-bg-hover); }

        .loading-overlay{
          position:absolute;
          top:50%;left:50%;
          transform:translate(-50%,-50%);
          z-index:3000;
          pointer-events:none;
        }
        .spinner{
          width:40px;height:40px;
          border:4px solid rgba(0,0,0,.15);
          border-top:4px solid #1e88e5;
          border-radius:50%;
          animation:spin 1s linear infinite;
        }
        @keyframes spin{ to{ transform:rotate(360deg); } }


        /* Compact QR button follows theme */
        .qr-btn {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 4px;
          width: 42px; height: 42px;
          padding: 4px;
          display: flex; align-items: center; justify-content: center;
          cursor: pointer;
          color: var(--modal-text);
          box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
        .qr-btn:hover { background: var(--control-bg-hover); }
        .qr-btn svg { width: 22px; height: 22px; display: block; }

        /* Leaflet controls use theme variables so colors follow the current theme */
        .leaflet-control-layers,
        .leaflet-control-layers-toggle,
        .leaflet-control-layers-list,
        .leaflet-control-layers-expanded,
        .leaflet-bar a {
          background-color: var(--control-bg);
          border: var(--legend-border);
          color: var(--modal-text);
        }

        .leaflet-control-layers-toggle:hover,
        .leaflet-bar a:hover {
          background-color: var(--control-bg-hover);
        }

        /* Ensure layer labels match theme text color */
        .leaflet-control-layers label { color: var(--modal-text); }

        /* ===== Leaflet layer control ===== */
        /* Remove border and shadow around map type selector to blend into map */
        .leaflet-control-layers,
        .leaflet-control-layers-expanded,
        .leaflet-control-layers-list {
          box-shadow: none;
        }

        /* Removed old collapsible legend styles (legend-control, legend-header, legend-title, legend-toggle, legend-body, legend-row, legend-swatch, legend-label)
           to avoid duplicate legends. Only the compact legend + modal remain. */

        /* Live marker icon now combines the heart logo with the dose value. */
        .live-marker {
          border-radius: 50%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          gap: 2px;
          text-align: center;
          font-weight: 600;
          font-family: var(--font-family-base);
          box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);
          color: #000;
          overflow: hidden;
        }

        .live-marker-heart {
          display: block;
          width: 60%;
          height: auto;
          pointer-events: none;
        }

        .live-marker-value {
          line-height: 1;
          font-size: 0.55em;
          letter-spacing: -0.02em;
        }



				/* ---- Unified tooltip/popup sizing & wrapping ----
					 Keep tooltip (hover) and popup (click) the same width.
					 Leaflet's default popup maxWidth is ~300px, so we reuse that.
					 Adjust --tooltip-max if you want it wider/narrower in one place. */
				:root {
					--tooltip-max: 300px;   /* single source of truth for both tooltip & popup widths */
					--tooltip-min: 220px;   /* prevents collapsing into a thin vertical strip */
				}

				/* Wrapper used inside both tooltip and popup content */
				.live-tooltip {
					max-width: var(--tooltip-max);  /* wider than old 260px */
				}

				/* Leaflet tooltip content (hover). Make it match popup width and wrap nicely. */
				.leaflet-tooltip.custom-tooltip {
					white-space: normal;            /* allow line wrapping */
					max-width: var(--tooltip-max);  /* match popup max width */
					min-inline-size: var(--tooltip-min); /* avoid skinny column */
					overflow-wrap: break-word;      /* break long words/URLs only when needed */
					word-break: break-word;         /* compatibility for older browsers */
					hyphens: auto;                  /* nicer hyphenation when available */
				}

				/* Leaflet popup content (click). Enforce the same max width to match tooltip. */
				.leaflet-popup-content {
					max-width: var(--tooltip-max);  /* unify with tooltip width */
				}

				/* Flex header: allow text to shrink in flex so it doesn't overflow. */
				.live-tooltip-header {
					display: flex;
					gap: 10px;
					align-items: center;
					margin-bottom: 6px;
					min-width: 0;                   /* critical for proper flex text shrinking */
				}

				/* Fixed-size heart icon so it doesn't affect layout */
				.live-tooltip-heart {
					width: 28px;
					height: 28px;
					flex: 0 0 28px;
				}

				/* Title and description: let text wrap and shrink inside flex */
				.live-tooltip-title,
				.live-tooltip-desc {
					margin: 0;
					min-width: 0;                   /* allow shrinking in flex */
					flex: 1 1 auto;                 /* take available space without overflowing */
				}

        .live-tooltip-desc {
          font-size: var(--font-size-sm);
          line-height: 1.4;
        }

        /* Highlight realtime dose with large numerals while keeping context compact. */
        .live-popup-dose {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 6px;
          margin: 6px 0;
        }

        .live-popup-dose-primary {
          font-size: var(--font-size-display);
          font-weight: 700;
          line-height: 1;
          letter-spacing: -0.01em;
        }

        .live-popup-dose-unit {
          margin-left: 6px;
          font-size: var(--font-size-base);
          font-weight: 500;
        }

        .live-popup-dose-secondary {
          font-size: var(--font-size-sm);
          opacity: 0.85;
        }

        .live-popup-dose-status {
          padding: 4px 10px;
          border-radius: 6px;
          font-size: var(--font-size-sm);
          font-weight: 600;
        }

        .live-popup-climate {
          font-size: var(--font-size-base);
          font-weight: 500;
        }

        .live-popup-meta {
          font-size: var(--font-size-xs);
          line-height: 1.4;
          opacity: 0.85;
          display: grid;
          gap: 4px;
          margin-top: 6px;
        }

        .live-popup-meta strong {
          font-weight: 600;
        }

        .live-popup-small-link {
          font-size: var(--font-size-xs);
          display: inline-block;
          margin-top: 4px;
        }



        .live-extra-list {
          margin: 4px 0 0 0;
          padding-left: 18px;
        }

        .live-extra-list li {
          margin: 2px 0;
        }

        /* Keep the icons in the speed filter aligned regardless of emoji vs. SVG source. */
        .speed-filter-icon {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 1.5em;
          height: 1.5em;
          margin-left: 6px;
          font-size: 1.2em;
          line-height: 1;
        }

        /* Ensure the SVG heart scales with the surrounding emoji-based icons. */
        .speed-filter-icon img {
          display: block;
          width: 100%;
          height: 100%;
        }

        /* Apply grayscale filter so emoji icons render in monochrome without altering other assets. */
        .speed-filter-icon--mono {
          filter: grayscale(1) brightness(1) contrast(1);
        }

        #liveModal, #spectrumModal {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.6);
          z-index: 2100;
          justify-content: center;
          align-items: center;
        }

        .live-modal-content {
          background: var(--modal-bg);
          color: var(--modal-text);
          border: var(--modal-border);
          width: min(720px, 92%);
          max-height: 85vh;
          overflow-y: auto;
          padding: 20px;
          border-radius: 12px;
          box-shadow: 0 0 12px rgba(0, 0, 0, 0.45);
          font-family: inherit;
          display: flex;
          flex-direction: column;
          gap: 16px;
        }

        .live-modal-header {
          display: flex;
          align-items: center;
          gap: 14px;
        }

        .live-modal-top {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          gap: 20px;
        }

        .live-modal-meta-wrapper {
          flex: 1;
        }

        .live-modal-dose-display {
          text-align: right;
          min-width: 200px;
          display: flex;
          flex-direction: column;
          gap: 8px;
        }

        .live-modal-dose-value {
          font-size: 3.5rem;
          font-weight: bold;
          line-height: 1;
          margin: 0;
        }

        .live-modal-dose-alt {
          font-size: 1.5rem;
          color: var(--modal-text);
          margin: 0;
        }

        .live-modal-dose-temp {
          font-size: 0.9rem;
          color: var(--modal-text);
          opacity: 0.75;
          margin: 0;
        }

        .live-modal-dose-time {
          font-size: 0.9rem;
          color: var(--modal-text);
          opacity: 0.85;
          margin: 8px 0 0 0;
          padding-top: 8px;
          border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .temp-unit-toggle {
          display: inline-flex;
          align-items: center;
          gap: 4px;
          padding: 2px 8px;
          font-size: 0.75rem;
          background: var(--modal-bg);
          border: 1px solid var(--legend-border);
          border-radius: 4px;
          cursor: pointer;
          color: var(--modal-text);
          opacity: 0.7;
          transition: opacity 0.2s;
        }

        .temp-unit-toggle:hover {
          opacity: 1;
        }

        .temp-unit-toggle.active {
          opacity: 1;
          background: rgba(255, 112, 67, 0.2);
          border-color: #ff7043;
        }

        .live-modal-heart {
          width: 40px;
          height: 40px;
        }

        .live-modal-title {
          margin: 0;
          font-size: var(--font-size-xl);
        }

        .live-modal-description {
          margin: 4px 0 0 0;
          line-height: 1.6;
        }

        .live-modal-meta {
          display: grid;
          gap: 6px;
          font-size: var(--font-size-base);
        }

        .live-chart-stack {
          display: flex;
          flex-direction: column;
          gap: 12px;
        }

        .live-range-selector {
          display: flex;
          gap: 4px;
          margin-bottom: 4px;
        }

        .live-range-btn {
          padding: 4px 12px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 6px;
          cursor: pointer;
          color: var(--modal-text);
          font-size: var(--font-size-sm);
          opacity: 0.7;
          transition: opacity 0.2s, background 0.2s;
        }

        .live-range-btn:hover {
          opacity: 1;
        }

        .live-range-btn.active {
          opacity: 1;
          background: var(--isotope-highlight);
          color: #000;
          font-weight: 600;
        }

        .live-chart-block {
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 10px;
          padding: 12px;
        }

        .live-chart-title {
          margin: 0 0 8px 0;
          display: flex;
          flex-wrap: wrap;
          gap: 4px 12px;
          align-items: baseline;
        }

        .live-chart-label {
          font-size: var(--font-size-base);
          font-weight: 600;
          flex: 1 1 auto;
        }

        .live-chart-unit {
          font-size: var(--font-size-sm);
          color: var(--modal-text);
          opacity: 0.8;
        }

        .live-chart-window {
          font-size: var(--font-size-xs);
          color: var(--modal-text);
          opacity: 0.7;
        }

        .live-chart-canvas {
          display: block;
          width: 100%;
          height: 320px;
          border-radius: 6px;
          background: rgba(0,0,0,0.05);
          cursor: crosshair;
        }

        .live-chart-empty {
          margin: 0;
          font-size: var(--font-size-sm);
          color: var(--modal-text);
        }

        .live-modal-close {
          align-self: flex-end;
          padding: 6px 14px;
          background: var(--control-bg);
          border: var(--legend-border);
          border-radius: 6px;
          cursor: pointer;
          font-family: inherit;
          color: var(--modal-text);
        }

    </style>

    <!-- Translation script -->
    <script id="translations-script">
      // Translation object passed from Go
      // We emit ready-made JS literals to keep html/template from misdetecting
      // the surrounding string context when translations contain quotes.
      var translations = {{ .TranslationsJSON }};
        var currentLang = '{{ .Lang }}'; // Current language

        // Get translation by key
        function translate(key) {
            if (!translations['en']) {
                console.error('English translations not available!');
                return key;
            }

            if (translations[currentLang] && translations[currentLang][key]) {
                return translations[currentLang][key];
            } else if (translations['en'][key]) {
                return translations['en'][key];
            }
            return key;
        }
    </script>
    <script>
      const defaultCfg = {
        lat:  {{printf "%.6f" .DefaultLat}},
        lon:  {{printf "%.6f" .DefaultLon}},
        zoom: {{.DefaultZoom}},
        layer: {{ printf "%q" .DefaultLayer }},
        autoLocate: {{if .AutoLocateDefault}}true{{else}}false{{end}}
      };
    </script>
    <script>
      // Surface the configured support e-mail so the legal dialog can show a contact when available.
      window.supportEmail = {{if .SupportEmail}}{{printf "%q" .SupportEmail}}{{else}}""{{end}};
    </script>
    <script>
      // Expose the realtime flag so the UI can hide controls when the backend keeps the feature off.
      window.safecastRealtimeEnabled = {{if .RealtimeAvailable}}true{{else}}false{{end}};
    </script>

  </head>

  <body>

    <!-- Container for upload button -->
    <div class="upload-btn-container leaflet-control">
      <!--
        title/aria-label ‚Üí short hint on hover/focus about formats
        and what happens after upload.
      -->
      <label
        for="fileInput"
        class="upload-btn"
        aria-label="{{translate "upload_button_tooltip"}}">
        {{translate "upload_button"}}
      </label>

      <input
        type="file"
        id="fileInput"
        style="display: none;"
        multiple
        accept=""
        onchange="uploadFiles()">
    </div>

    <!-- Container for geolocation button -->
    <div class="locate-btn-container leaflet-control">
      <button id="locateButton" class="locate-btn" aria-label="{{translate "locate_button_tooltip"}}">
        <img src="/static/images/marker-icon-2x.png" alt="Locate" style="width:20px;">
      </button>
      <br>
      <!-- Small QR button under geolocate -->
      <button id="qrButton" class="qr-btn" aria-label="{{translate "qr_button_tooltip"}}">
        <svg viewBox="0 0 100 100" role="img" aria-hidden="true">
          <rect x="0" y="0" width="100" height="100" fill="#fff"/>
          <rect x="8" y="8" width="28" height="28" fill="#000"/>
          <rect x="12" y="12" width="20" height="20" fill="#fff"/>
          <rect x="16" y="16" width="12" height="12" fill="#000"/>
          <rect x="64" y="8" width="28" height="28" fill="#000"/>
          <rect x="68" y="12" width="20" height="20" fill="#fff"/>
          <rect x="72" y="16" width="12" height="12" fill="#000"/>
          <rect x="8" y="64" width="28" height="28" fill="#000"/>
          <rect x="12" y="68" width="20" height="20" fill="#fff"/>
          <rect x="16" y="72" width="12" height="12" fill="#000"/>
          <rect x="48" y="12" width="8" height="8" fill="#000"/>
          <rect x="40" y="28" width="8" height="8" fill="#000"/>
          <rect x="56" y="28" width="8" height="8" fill="#000"/>
          <rect x="44" y="44" width="8" height="8" fill="#000"/>
          <rect x="60" y="44" width="8" height="8" fill="#000"/>
          <rect x="44" y="60" width="8" height="8" fill="#000"/>
          <rect x="60" y="60" width="8" height="8" fill="#000"/>
          <rect x="76" y="60" width="8" height="8" fill="#000"/>
          <rect x="28" y="44" width="8" height="8" fill="#000"/>
        </svg>
      </button>
    </div>

    <!-- Container for "Back to all tracks" button -->
    <div class="back-to-all-container leaflet-control" style="display: none;">
      <button id="backToAllButton" class="back-to-all-btn">{{ translate "back_to_all_tracks" }}</button>
    </div>

    <!-- Track download button appears only in track view so users can retrieve the original JSON quickly. -->
    <div class="download-track-container leaflet-control" style="display: none;">
      <a id="downloadTrackLink" class="download-track-btn" href="#">{{ translate "download_track_cim" }}</a>
    </div>

    <!-- File upload overlay -->
    <div id="fileOverlay" style="display: none;">
      <div id="fileProgressContainer">
        <!-- Upload progress entries inserted here dynamically -->
      </div>
    </div>

    <!-- GitHub link and program info -->
    <a href="https://github.com/Safecast/safecast-new-map" class="github-link" target="_blank" rel="noopener noreferrer" aria-label="{{translate "github_link_tooltip_desc"}}">
      <img src="/static/images/safecast-logo-squared.png" alt="{{translate "description"}} (version: {{ .Version }})" class="github-icon">
    </a>

    <!-- Short link pill shows the shareable URL and copies it on click -->
    <div
      id="shortLinkDisplay"
      role="button"
      tabindex="0"
      aria-live="polite"
      aria-label="{{translate "short_link_tooltip"}}"></div>

    <!-- Map container -->
    <div id="map"></div>

    <div id="loadingOverlay" class="loading-overlay" style="display:none;">
      <div class="spinner"></div>
    </div>

    <!-- Theme toggle -->
    <div id="themeToggle" role="button" tabindex="0" aria-label="{{translate "theme_toggle_tooltip"}}">
      <span class="theme-icon">‚òÄÔ∏è</span>
      <label class="theme-switch">
        <input type="checkbox" id="themeSwitch">
        <span class="theme-slider"></span>
      </label>
      <span class="theme-icon">üåô</span>
    </div>

<!-- Unit Toggle Button -->
<button id="unitToggle" aria-label="Toggle between ¬µR/h and ¬µSv/h" style="
  position: absolute;
  bottom: 20px;
  right: 120px;
  background: var(--control-bg);
  border: var(--legend-border);
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0,0,0,0.65);
  padding: 3px 10px;
  font-size: var(--font-size-base);
  cursor: pointer;
  z-index: 1000;
  color: var(--modal-text);
  font-family: var(--font-family-base);
  transition: background 0.2s;">‚áÑ</button>

<!-- Compact Legend (clickable) -->
<div id="legend" role="button" tabindex="0" aria-label="{{translate "legend_button_tooltip"}}" style="
  position: absolute;
  bottom: 50px;
  right: 10px;
  background: var(--control-bg);
  border: var(--legend-border);
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0,0,0,0.65);
  padding: 5px;
  font-size: var(--font-size-sm);
  cursor: pointer;
  z-index: 1000;
  font-family: var(--font-family-base);
  height: 500px;
  display: flex;">
    <div id="legend-bar" style="width:24px; margin-right:8px; border-radius:12px; border: 1px solid rgba(0,0,0,0.2);"></div>
    <div id="legend-labels" style="display:flex; flex-direction:column; justify-content:space-between; height:100%; font-weight:bold; min-width:35px; text-align:left;">
    </div>
    <div style="position:absolute; bottom:20px;right:5px;width:100%;text-align:center; font-size:15px; font-weight:bold; color:var(--modal-text); text-shadow: 0 0 2px var(--control-bg);">
       <span id="legend-unit-label">¬µSv/h</span>
    </div>
</div>
<!--
  Compact 4-bin legend with vertical gradient bar showing radiation levels.
  Color scale: Blue (low/safe) ‚Üí Cyan ‚Üí Purple ‚Üí Magenta ‚Üí Red ‚Üí Orange ‚Üí Yellow (high/danger)
  Based on world background radiation baseline of ~0.10 ¬µSv/h (external only).
  Clicking the legend opens a modal with full, human-friendly guidance.
-->
<!-- Legend Modal -->
<div id="legendModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">{{translate "legend_title"}}</h3>
    <!-- We inject the localized full text below -->
    <div id="legendText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('legendModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>
<!--
  Modal that displays the full, localized legend text.
  `white-space:pre-wrap` preserves paragraphs and bullets from translations.json.
  Box scrolls when content is long.
-->

<!-- Generic Info Modal for legal notes, data sources, and license -->
<div id="infoModal" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 id="infoTitle" style="margin-top:0;"></h3>
    <div id="infoText" style="line-height:1.6em;"></div>
    <div style="margin-top:12px; text-align:right;">
      <button onclick="document.getElementById('infoModal').style.display='none'"
        style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- Provide dedicated modal for reading the full MIT License directly on the map. -->
<div class="license-modal" data-license="mit" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">MIT License</h3>
    <pre class="license-modal-body" data-license-url="/licenses/mit" data-license-loaded="false" data-license-loading="false" style="white-space:pre-wrap; margin:0; font-family: var(--font-family-base);">Loading‚Ä¶</pre>
    <div style="margin-top:12px; text-align:right;">
      <button class="license-modal-close" data-license="mit" style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>
</div>

<!-- Provide dedicated modal for reading the full CC0 1.0 Universal text. -->
<div class="license-modal" data-license="cc0" style="
  display:none;
  position:fixed;
  top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.6);
  z-index:2000;
  justify-content:center;
  align-items:center;">
  <div style="
    background:var(--modal-bg);
    color:var(--modal-text);
    border:var(--modal-border);
    max-width:720px;
    max-height:80vh;
    overflow-y:auto;
    padding:20px;
    border-radius:10px;
    font-size: var(--font-size-base);
    line-height:1.6em;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-family: var(--font-family-base);">
    <h3 style="margin-top:0;">CC0 1.0 Universal</h3>
    <pre class="license-modal-body" data-license-url="/licenses/cc0" data-license-loaded="false" data-license-loading="false" style="white-space:pre-wrap; margin:0; font-family: var(--font-family-base);">Loading‚Ä¶</pre>
    <div style="margin-top:12px; text-align:right;">
      <button class="license-modal-close" data-license="cc0" style="padding:6px 12px; background: var(--control-bg); border: var(--legend-border); border-radius:4px; cursor:pointer; font-family: inherit;">
        OK
      </button>
    </div>
  </div>

</div>


<!-- Modal with Grafana-style stacked charts for Safecast realtime sensors -->

<div id="liveModal">
  <div class="live-modal-content">
    <div class="live-modal-header">
      <img src="/static/images/safecast-heart-logo.png" alt="Safecast realtime sensor" class="live-modal-heart">
      <div>
        <h3 id="liveModalTitle" class="live-modal-title"></h3>
        <p id="liveModalDescription" class="live-modal-description"></p>
      </div>
    </div>
    <div class="live-modal-top">
      <div class="live-modal-meta-wrapper">
        <div id="liveModalMeta" class="live-modal-meta"></div>
        <div id="liveModalExtra" class="live-modal-meta"></div>
      </div>
      <div id="liveModalDose" class="live-modal-dose-display"></div>
    </div>
    <div class="live-chart-stack">
      <div class="live-range-selector">
        <button class="live-range-btn active" data-range="day">24h</button>
        <button class="live-range-btn" data-range="month">30d</button>
        <button class="live-range-btn" data-range="all">All</button>
        <button class="temp-unit-toggle" id="tempUnitToggle" title="Toggle temperature unit">¬∞C</button>
      </div>
      <div class="live-chart-block">
        <h4 class="live-chart-title">
          <span class="live-chart-label" id="liveChartTitle"></span>
          <span class="live-chart-unit">¬µR/h</span>
          <span class="live-chart-window" id="liveChartWindow"></span>
        </h4>
        <canvas id="liveChartCanvas" class="live-chart-canvas"></canvas>
        <p id="liveChartEmpty" class="live-chart-empty"></p>
      </div>
    </div>
    <button type="button" class="live-modal-close" id="liveModalClose"></button>
  </div>
</div>

<div id="spectrumModal">
  <div class="live-modal-content">
    <div class="live-modal-header">
      <div style="font-size: 40px; line-height: 1;">üìä</div>
      <div>
        <h3 id="spectrumModalTitle" class="live-modal-title">Gamma Spectrum</h3>
        <p id="spectrumModalDescription" class="live-modal-description"></p>
      </div>
    </div>
    <div id="spectrumModalMeta" class="live-modal-meta"></div>
    <div class="live-chart-stack">
      <div class="live-chart-block">
        <h4 class="live-chart-title">
          <span class="live-chart-label">Energy Spectrum</span>
          <span class="live-chart-unit">Counts</span>
        </h4>
        <canvas id="spectrumChart" class="live-chart-canvas"></canvas>
        <p id="spectrumChartEmpty" class="live-chart-empty"></p>
      </div>
    </div>
    <div id="spectrumIsotopes" style="margin-top: 16px; padding: 12px; background: var(--control-bg); border: var(--legend-border); border-radius: 8px;">
      <h4 style="margin: 0 0 8px 0; font-size: var(--font-size-base); font-weight: 600; color: var(--modal-text);">Common Isotope Peaks Reference</h4>
      <div id="spectrumIsotopeList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 4px 12px; font-size: var(--font-size-sm);">
        <!-- Will be populated dynamically with isotope reference list -->
        <div style="padding: 4px 0; color: var(--modal-text); opacity: 0.6; font-style: italic;">Loading isotope database...</div>
      </div>
    </div>
    <div style="margin-top: 16px; text-align: center;">
      <button id="spectrumDownloadJSON" style="margin: 4px; padding: 8px 16px; background: var(--control-bg); border: var(--legend-border); border-radius: 6px; cursor: pointer; color: var(--modal-text);">Download JSON</button>
      <button id="spectrumDownloadCSV" style="margin: 4px; padding: 8px 16px; background: var(--control-bg); border: var(--legend-border); border-radius: 6px; cursor: pointer; color: var(--modal-text);">Download CSV</button>
    </div>
    <button type="button" class="live-modal-close" id="spectrumModalClose">Close</button>
  </div>
</div>

<!-- Coordinate Input Dialog for spectrum files without GPS -->
<div id="coordinateInputDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10001; align-items: center; justify-content: center;">
  <div style="background: var(--modal-bg); padding: 24px; border-radius: 12px; max-width: 500px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
    <h3 style="margin: 0 0 16px 0; color: var(--modal-text); font-size: 20px;">üìç Set Spectrum Location</h3>
    <p style="margin: 0 0 20px 0; color: var(--modal-text); opacity: 0.8; font-size: var(--font-size-base);">
      This spectrum file doesn't contain GPS coordinates. Please enter the location where the measurement was taken.
    </p>

    <div style="margin-bottom: 16px;">
      <label style="display: block; margin-bottom: 6px; color: var(--modal-text); font-weight: 600;">Latitude:</label>
      <input type="number" id="coordInputLat" step="0.000001" placeholder="e.g., 34.4883891"
             style="width: 100%; padding: 10px; border: var(--legend-border); border-radius: 6px; background: var(--control-bg); color: var(--modal-text); font-size: var(--font-size-base); box-sizing: border-box;">
    </div>

    <div style="margin-bottom: 20px;">
      <label style="display: block; margin-bottom: 6px; color: var(--modal-text); font-weight: 600;">Longitude:</label>
      <input type="number" id="coordInputLon" step="0.000001" placeholder="e.g., 136.1659156"
             style="width: 100%; padding: 10px; border: var(--legend-border); border-radius: 6px; background: var(--control-bg); color: var(--modal-text); font-size: var(--font-size-base); box-sizing: border-box;">
    </div>

    <div style="display: flex; gap: 12px; margin-bottom: 16px;">
      <button id="coordMapPickBtn" style="flex: 1; padding: 10px; background: var(--control-bg); border: var(--legend-border); border-radius: 6px; cursor: pointer; color: var(--modal-text); font-size: var(--font-size-base);">
        üìå Click on Map
      </button>
      <button id="coordCurrentBtn" style="flex: 1; padding: 10px; background: var(--control-bg); border: var(--legend-border); border-radius: 6px; cursor: pointer; color: var(--modal-text); font-size: var(--font-size-base);">
        üìç Use Current Location
      </button>
    </div>

    <div style="display: flex; gap: 12px;">
      <button id="coordSubmitBtn" style="flex: 1; padding: 12px; background: #4CAF50; border: none; border-radius: 6px; cursor: pointer; color: white; font-weight: 600; font-size: var(--font-size-base);">
        Submit Location
      </button>
      <button id="coordCancelBtn" style="flex: 1; padding: 12px; background: #f44336; border: none; border-radius: 6px; cursor: pointer; color: white; font-weight: 600; font-size: var(--font-size-base);">
        Cancel
      </button>
    </div>

    <p id="coordInputError" style="margin: 12px 0 0 0; color: #f44336; font-size: var(--font-size-sm); display: none;"></p>
    <p id="coordInputStatus" style="margin: 12px 0 0 0; color: var(--isotope-highlight); font-size: var(--font-size-sm); opacity: 0.8;"></p>
  </div>
</div>

    <!-- Load Leaflet JavaScript library -->
    <script src="/static/leaflet.js"></script>

    <!-- Chart.js for spectrum visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>

    <!-- Slider -->
    <script src="/static/nouislider.min.js"></script>
    <script src="/static/wNumb.min.js"></script>



    <!-- Helper functions -->
    <script>
      // Cache typography tokens so dynamic canvases reuse the same styling as CSS.
      let cachedFontTokens;
      function resolveFontTokens() {
        if (cachedFontTokens) return cachedFontTokens;
        const root = document.documentElement;
        const styles = window.getComputedStyle(root);
        const fallbackFamily = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        const familyRaw = (styles.getPropertyValue('--font-family-base') || '').trim();
        const family = familyRaw || fallbackFamily;

        function pickSize(varName, defaultSize) {
          const value = (styles.getPropertyValue(varName) || '').trim();
          return value || defaultSize;
        }

        cachedFontTokens = {
          family: family,
          xs: pickSize('--font-size-xs', '6px'),
          sm: pickSize('--font-size-sm', '10px'),
          base: pickSize('--font-size-base', '12px'),
          lg: pickSize('--font-size-lg', '14px'),
          xl: pickSize('--font-size-xl', '20px'),
          display: pickSize('--font-size-display', '28px'),
        };
        return cachedFontTokens;
      }

      // Compute marker color from radiation level
      // Based on world background radiation baseline of ~0.10 ¬µSv/h (external only)
      // Defined globally for Map and Legend usage - 15 step scale
      const schemeSafecast = [
        { uSv: 0.03, color: [0, 0, 139] },    // DarkBlue
        { uSv: 0.05, color: [0, 71, 171] },   // Cobalt
        { uSv: 0.08, color: [65, 105, 225] }, // RoyalBlue
        { uSv: 0.12, color: [135, 206, 250] },// LightSkyBlue
        { uSv: 0.16, color: [0, 191, 255] },  // DeepSkyBlue
        { uSv: 0.23, color: [0, 255, 255] },  // Cyan
        { uSv: 0.31, color: [64, 224, 208] }, // Turquoise
        { uSv: 0.43, color: [147, 112, 219] },// MediumPurple
        { uSv: 0.60, color: [186, 85, 211] }, // MediumOrchid
        { uSv: 0.87, color: [255, 0, 255] },  // Magenta
        { uSv: 1.31, color: [255, 20, 147] }, // DeepPink
        { uSv: 2.13, color: [255, 0, 0] },    // Red
        { uSv: 3.99, color: [255, 69, 0] },   // Red-Orange
        { uSv: 10.09, color: [255, 165, 0] }, // Orange
        { uSv: 65.54, color: [255, 255, 0] }  // Yellow
      ];

      const schemeChicha = [
        { uSv: 0.00, color: [0, 128, 0] },   // Green (0-11 uR/h)
        { uSv: 0.11, color: [255, 215, 0] }, // Yellow (11-30 uR/h)
        { uSv: 0.30, color: [255, 69, 0] },  // Red (30-100 uR/h)
        { uSv: 1.00, color: [0, 0, 0] }      // Black (>100 uR/h)
      ];

      // Global refs
      let currentColoring = 'safecast'; 
      let radiationSteps = schemeSafecast;

      function getGradientColor(doseRate) {
          // Use interpolation for both schemes to provide a smooth gradient
          const steps = (currentColoring === 'chicha') ? schemeChicha : schemeSafecast;

          if (doseRate <= steps[0].uSv) return `rgb(${steps[0].color.join(',')})`;
          if (doseRate >= steps[steps.length-1].uSv) return `rgb(${steps[steps.length-1].color.join(',')})`;

          for (let i = 0; i < steps.length - 1; i++) {
              const lower = steps[i];
              const upper = steps[i+1];
              if (doseRate >= lower.uSv && doseRate <= upper.uSv) {
                  return interpolateColor(lower.color, upper.color, (doseRate - lower.uSv) / (upper.uSv - lower.uSv));
              }
          }
          return '#FFFF00';
      }

// Interpolate between two colors
function interpolateColor(color1, color2, factor) {
  if (factor < 0) factor = 0;
  if (factor > 1) factor = 1;

  const r = Math.round(color1[0] + (color2[0] - color1[0]) * factor);
  const g = Math.round(color1[1] + (color2[1] - color1[1]) * factor);
  const b = Math.round(color1[2] + (color2[2] - color1[2]) * factor);

  return `rgb(${r}, ${g}, ${b})`;
}

// Calculate marker radius based on zoom level
function getRadius(doseRate, zoomLevel) {
  // previous formula: Math.pow(2, (zoomLevel-10)/2)
  const k = 1;                               // scale by ~2
  let r   = Math.pow(2, (zoomLevel - 10)/2.5) * k;
  return Math.max(r, 2);                       // prevent tiny circles
}

// Thresholds for realtime freshness expressed in seconds so both the
// rendering loop and periodic refresh share the same rules.
const LIVE_ACTIVE_WINDOW = 5 * 60;         // 5 minutes keeps "working" sensors bright
const LIVE_RECENT_WINDOW = 24 * 60 * 60;   // 24 hours before removal

// parseColor extracts RGB components from either hex (#rrggbb) or rgb(r,g,b)
// strings.  Keeping this helper local avoids pulling external libraries while
// letting us reuse the logic for alpha blending and contrast checks.
function parseColor(color) {
  if (!color) return null;
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    if (hex.length === 6) {
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16),
      };
    }
    if (hex.length === 3) {
      return {
        r: parseInt(hex[0] + hex[0], 16),
        g: parseInt(hex[1] + hex[1], 16),
        b: parseInt(hex[2] + hex[2], 16),
      };
    }
  }
  if (color.startsWith('rgb')) {
    const parts = color.match(/\d+/g);
    if (parts && parts.length >= 3) {
      return {
        r: parseInt(parts[0], 10),
        g: parseInt(parts[1], 10),
        b: parseInt(parts[2], 10),
      };
    }
  }
  return null;
}

// colorWithAlpha returns an rgba() string using the provided alpha.  We reuse
// parseColor so realtime markers can reuse the same gradient palette while
// dimming stale sensors without affecting the text opacity.
function colorWithAlpha(color, alpha) {
  const rgb = parseColor(color);
  if (!rgb) return color;
  const a = Math.min(Math.max(alpha, 0), 1);
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`;
}

// isDarkColor estimates perceived brightness to choose a contrasting text
// color.  A simple luminance formula keeps the implementation lightweight.
function isDarkColor(color) {
  const rgb = parseColor(color);
  if (!rgb) return false;
  const luminance = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
  return luminance < 140;
}

// formatMicroRoentgen converts ¬µSv/h into ¬µR/h text while avoiding excessive
// decimals.  Smaller values keep two decimals; larger ones are rounded to the
// nearest whole number for quick scanning on the map.
function formatMicroRoentgen(doseRate) {
  const micro = doseRate * 100;
  if (micro >= 100) return micro.toFixed(0);
  if (micro >= 10) return micro.toFixed(1);
  if (micro >= 1) return micro.toFixed(2);
  return micro.toFixed(3);
}

// formatMicroRoentgenValue keeps axis labels tidy when the charts already work
// with ¬µR/h values.  Sharing the logic here avoids sprinkling the rounding
// heuristics through the drawing code.
function formatMicroRoentgenValue(value) {
  const abs = Math.abs(value);
  if (abs >= 100) return value.toFixed(0);
  if (abs >= 10) return value.toFixed(1);
  if (abs >= 1) return value.toFixed(2);
  return value.toFixed(3);
}

// formatChartValue formats chart values based on the current unit
// Note: chart values are stored in ¬µR/h, so we need to convert to ¬µSv/h if needed
function formatChartValue(value, forcedPrecision) {
  if (currentUnit === 'uSv') {
    // Convert ¬µR/h back to ¬µSv/h for display
    const svValue = value / 100;
    if (typeof forcedPrecision === 'number') {
      return svValue.toFixed(forcedPrecision);
    }
    const abs = Math.abs(svValue);
    if (abs >= 1) return svValue.toFixed(2);
    if (abs >= 0.1) return svValue.toFixed(3);
    return svValue.toFixed(4);
  } else {
    // For ¬µR/h
    if (typeof forcedPrecision === 'number') {
      return value.toFixed(forcedPrecision);
    }
    return formatMicroRoentgenValue(value);
  }
}

// formatMicroSievert formats ¬µSv/h values with appropriate decimal places
function formatMicroSievert(doseRate) {
  if (doseRate >= 1) return doseRate.toFixed(2);
  if (doseRate >= 0.1) return doseRate.toFixed(3);
  return doseRate.toFixed(4);
}

// formatPrimaryUnit formats the dose rate in the currently selected unit
function formatPrimaryUnit(doseRate) {
  return currentUnit === 'uSv' ? formatMicroSievert(doseRate) : formatMicroRoentgen(doseRate);
}

// formatSecondaryUnit formats the dose rate in the opposite unit
function formatSecondaryUnit(doseRate) {
  return currentUnit === 'uSv' ? formatMicroRoentgen(doseRate) : formatMicroSievert(doseRate);
}

// getPrimaryUnitLabel returns the current primary unit label
function getPrimaryUnitLabel() {
  return currentUnit === 'uSv' ? '¬µSv/h' : '¬µR/h';
}

// getSecondaryUnitLabel returns the opposite unit label
function getSecondaryUnitLabel() {
  return currentUnit === 'uSv' ? '¬µR/h' : '¬µSv/h';
}

// escapeHtml protects popups against user-supplied strings like device names.
// We rely on explicit lookup tables instead of quoting " inside the regex so
// Go's html/template parser keeps the surrounding <script> in a neutral state.
const ESCAPE_HTML_RE = /[&<>\u0022\u0027]/g;
const ESCAPE_HTML_LOOKUP = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
};
ESCAPE_HTML_LOOKUP['\u0022'] = '&quot;';
ESCAPE_HTML_LOOKUP['\u0027'] = '&#39;';
function escapeHtml(value) {
  if (value === null || value === undefined) return '';
  return String(value).replace(ESCAPE_HTML_RE, function(ch) {
    return ESCAPE_HTML_LOOKUP[ch] || ch;
  });
}

const regionNameCache = {};

// Cookie helpers
function setCookie(name, value, days) {
  const expires = new Date();
  expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
  document.cookie = name + '=' + value + ';expires=' + expires.toUTCString() + ';path=/';
}

function getCookie(name) {
  const nameEQ = name + '=';
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
  }
  return null;
}

function formatDateTime(ts) {
  if (!ts) return '‚Äî';
  const date = new Date(ts * 1000);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  return date.toLocaleString(lang, { hour12: false });
}

function approximateLocalTime(lat, lon) {
  if (typeof lon !== 'number' || !isFinite(lon)) return null;
  const offsetHours = Math.round(lon / 15);
  const offsetMs = offsetHours * 60 * 60 * 1000;
  const remote = new Date(Date.now() + offsetMs);
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const label = offsetHours === 0 ? 'UTC' : (offsetHours > 0 ? `UTC+${offsetHours}` : `UTC${offsetHours}`);
  return { text: remote.toLocaleString(lang, { hour12: false }), zone: label };
}

function transportLabel(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_transport_car');
  if (key.includes('bike')) return translate('live_marker_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_transport_air');
  return translate('live_marker_transport_unknown');
}

function transportSentence(transport) {
  const key = (transport || '').toLowerCase();
  if (key.includes('walk')) return translate('live_marker_desc_transport_walk');
  if (key.includes('car') || key.includes('van')) return translate('live_marker_desc_transport_car');
  if (key.includes('bike')) return translate('live_marker_desc_transport_bike');
  if (key.includes('air') || key.includes('plane')) return translate('live_marker_desc_transport_air');
  return translate('live_marker_desc_transport_unknown');
}

function localizeCountry(code) {
  if (!code) return '';
  const normalized = String(code).toUpperCase();
  if (normalized === '??') return normalized;
  const langRaw = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  let locale = langRaw === 'ua' ? 'uk' : langRaw;
  locale = locale.replace('_', '-');
  try {
    if (!regionNameCache[locale]) {
      regionNameCache[locale] = new Intl.DisplayNames([locale], { type: 'region' });
    }
    const label = regionNameCache[locale].of(normalized);
    if (label) return label;
  } catch (err) {
    // Older browsers may not support Intl.DisplayNames; fall back to the code below.
  }
  return normalized;
}

function describeLiveSensor(marker) {
  // We use bracket placeholders (e.g. [[name]]) so the Go template parser leaves
  // them untouched while still allowing readable replacement in the browser.
  const subject = marker.deviceName
    ? translate('live_marker_desc_named').replace('[[name]]', escapeHtml(marker.deviceName))
    : translate('live_marker_desc_generic');
  const placeName = marker.country ? localizeCountry(marker.country) : '';
  const place = placeName
    ? translate('live_marker_desc_location').replace('[[place]]', escapeHtml(placeName))
    : translate('live_marker_desc_location_unknown');
  const transport = transportSentence(marker.transport);
  const sensorName = marker.tube || marker.deviceName || '';
  const tube = sensorName
    ? translate('live_marker_desc_tube').replace('[[tube]]', escapeHtml(sensorName))
    : translate('live_marker_desc_no_tube');
  return [subject, place, transport, tube].join(' ');
}

function labelForExtraKey(key) {
  switch (key) {
    case 'temperature_c':
      return translate('live_marker_temperature');
    case 'temperature_f':
      return translate('live_marker_temperature'); // Use same label, unit will be added via suffix
    case 'humidity_percent':
      return translate('live_marker_humidity');
    case 'pressure_hpa':
      // Safecast Airnote units expose pressure alongside humidity; handling it
      // here keeps the legend consistent with the live charts.
      return translate('live_marker_pressure');
    default:
      return key.replace(/_/g, ' ').replace(/\b\w/g, function(m){ return m.toUpperCase(); });
  }
}

function formatExtraValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return null;
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1) + (key.endsWith('_f') ? ' ¬∞F' : ' ¬∞C');
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0) + ' %';
  }
  if (key === 'pressure_hpa') {
    // Pressure varies slowly, so one decimal keeps the tooltip readable.
    return value.toFixed(1) + ' hPa';
  }
  return value.toFixed(2);
}

// Adding pressure keeps environmental series grouped together for clarity.
const EXTRA_SERIES_ORDER = ['temperature_c', 'temperature_f', 'humidity_percent', 'pressure_hpa'];

// Temperature unit preference (Celsius or Fahrenheit)
let preferredTempUnit = getCookie('tempUnit') || 'C';

function extraUnitSuffix(key) {
  if (key === 'temperature_c') return '¬∞C';
  if (key === 'temperature_f') return '¬∞F';
  if (key === 'humidity_percent') return '%';
  if (key === 'pressure_hpa') return 'hPa';
  return '';
}

function formatExtraAxisValue(key, value) {
  if (typeof value !== 'number' || !isFinite(value)) return '';
  if (key === 'temperature_c' || key === 'temperature_f') {
    return value.toFixed(1);
  }
  if (key === 'humidity_percent') {
    return value.toFixed(0);
  }
  if (key === 'pressure_hpa') {
    return value.toFixed(1);
  }
  return value.toFixed(2);
}

function colorForExtraKey(key) {
  if (key === 'temperature_c' || key === 'temperature_f') return '#ff7043';
  if (key === 'humidity_percent') return '#26a69a';
  if (key === 'pressure_hpa') {
    // Pressure gets a calming blue to distinguish it from humidity's green.
    return '#5c6bc0';
  }
  return '#ab47bc';
}

function sortExtraKeys(keys) {
  return keys.sort(function(a, b) {
    const ai = EXTRA_SERIES_ORDER.indexOf(a);
    const bi = EXTRA_SERIES_ORDER.indexOf(b);
    const av = ai === -1 ? Number.MAX_SAFE_INTEGER : ai;
    const bv = bi === -1 ? Number.MAX_SAFE_INTEGER : bi;
    if (av === bv) return a.localeCompare(b);
    return av - bv;
  });
}

function hasExtraSeries(series) {
  if (!series || typeof series !== 'object') return false;
  return Object.keys(series).some(function(key){
    return Array.isArray(series[key]) && series[key].length;
  });
}

function renderLiveExtras(extra) {
  if (!extra || typeof extra !== 'object') return '';
  const items = [];
  Object.keys(extra).sort().forEach(function(key){
    const label = labelForExtraKey(key);
    const val = formatExtraValue(key, extra[key]);
    if (!label || !val) return;
    items.push('<li>' + label + ': ' + val + '</li>');
  });
  if (!items.length) return '';
  return '<div><strong>' + translate('live_marker_extra_intro') + ':</strong><ul class="live-extra-list">' + items.join('') + '</ul></div>';
}

function renderEnvironmentExtras(extra) {
  if (!extra || typeof extra !== 'object') return '';
  const items = [];
  
  // Temperature is now shown in the main dose display, so skip it here
  
  // Other environment data
  if (typeof extra.humidity_percent === 'number') {
    items.push(translate('live_marker_humidity') + ': ' + formatExtraValue('humidity_percent', extra.humidity_percent));
  }
  if (typeof extra.pressure_hpa === 'number') {
    items.push(translate('live_marker_pressure') + ': ' + formatExtraValue('pressure_hpa', extra.pressure_hpa));
  }
  
  if (!items.length) return '';
  return '<div><strong>' + translate('live_marker_extra_intro') + ':</strong><ul class="live-extra-list">' + items.map(i => '<li>' + i + '</li>').join('') + '</ul></div>';
}

function buildDeviceMeta(marker) {
  const rows = [];
  if (marker.deviceName) {
    rows.push('<div><strong>' + translate('live_marker_device_label') + ':</strong> ' + escapeHtml(marker.deviceName) + '</div>');
  }
  if (marker.deviceID) {
    rows.push('<div><strong>' + translate('live_marker_device_id') + ':</strong> ' + escapeHtml(marker.deviceID) + '</div>');
  }
  if (marker.transport) {
    rows.push('<div><strong>' + translate('live_marker_transport') + ':</strong> ' + transportLabel(marker.transport) + '</div>');
  }
  if (marker.tube) {
    rows.push('<div><strong>' + translate('live_marker_detector') + ':</strong> ' + escapeHtml(marker.tube) + '</div>');
  }
  if (marker.country) {
    const localized = localizeCountry(marker.country);
    const display = localized || marker.country;
    rows.push('<div><strong>' + translate('live_marker_country') + ':</strong> ' + escapeHtml(display) + '</div>');
  }
  return rows.join('');
}

// buildRealtimeIcon returns the HTML markup and sizing data for a realtime
// marker.  It handles the three freshness buckets: active (white ring, opaque),
// recent (grey ring, half opacity), and stale (>24h, hidden).
function buildRealtimeIcon(marker, zoomLevel, nowSec) {
  const lastSeen = marker.date || 0;
  if (!lastSeen) return null;

  const ageSec = nowSec - lastSeen;
  if (ageSec > LIVE_RECENT_WINDOW) {
    return null; // drop sensors that have been silent longer than a day
  }

  const active = ageSec <= LIVE_ACTIVE_WINDOW;
  const baseColor = getGradientColor(marker.doseRate);
  const fill = active ? baseColor : colorWithAlpha(baseColor, 0.5);
  const border = active ? '#ffffff' : '#888888';
  const textColor = isDarkColor(active ? baseColor : fill) ? '#ffffff' : '#000000';

  const radius = getRadius(marker.doseRate, zoomLevel) * 3;
  const size = radius * 3.7;
  const value = formatPrimaryUnit(marker.doseRate);
  const fontSize = Math.max(Math.round(size * 0.32), 11);
  const heartSize = Math.max(Math.round(size * 0.5), 14);

  const html = `
    <div class="live-marker" style="background:${fill};border:2px solid ${border};color:${textColor};width:${size}px;height:${size}px;font-size:${fontSize}px;">
      <img class="live-marker-heart" src="/static/images/safecast-heart-logo.png" alt="Safecast" style="width:${heartSize}px;"/>
      <div class="live-marker-value">${value}</div>
    </div>`;

  return { html, size, radius };
}


/**
 * Decide whether the marker with given speed (m/s)
 * should be displayed according to current speed-filter state.
 * In single-track view there is no filtering ‚Äî show everything.
 */
function shouldDisplayBySpeed(speed) {
  /* Key line */
  if (isTrackView) return true;        // filter disabled in track view

  const st = loadSpeedFilterState();   // global mode
  if (speed < 0) {                     // Safecast heart markers use negative speed to signal realtime data
    if (!window.safecastRealtimeEnabled) {
      // Safety net: when realtime is disabled we never show synthetic negative speeds.
      return false;
    }
    return st.live;
  }
  if (speed >= 70 && speed <= 500) return st.plane;  // ‚úàÔ∏è
  if (speed >= 7  && speed <  70)  return st.car;    // üöó
  /* speed < 7 m/s  ‚Üí pedestrian */
  return st.ped;                                      // üö∂
}


// Compute marker fill opacity based on speed
// Speed ranges: Walking <7 m/s, Car 7-70 m/s, Plane ‚â•70 m/s
function getFillOpacity(speed) {
  if (speed < 7) {
    // Walking/pedestrian
    return 0.9;
  } else if (speed < 40) {
    // Car (slow) - linear gradient from 0.9 to 0.7
    var opacityRange = 0.9 - 0.7;
    var speedRange = 40 - 7;
    var factor = (speed - 7) / speedRange;
    return 0.9 - (opacityRange * factor);
  } else if (speed < 70) {
    // Car (fast) - linear gradient from 0.7 to 0.5
    var opacityRange = 0.7 - 0.5;
    var speedRange = 70 - 40;
    var factor = (speed - 40) / speedRange;
    return 0.7 - (opacityRange * factor);
  } else {
    // Plane
    return 0.3;
  }
}

// Decide a translation key for safety based on dose rate (¬µSv/h).
// Using legend thresholds keeps UI consistent and avoids extra strings.
function doseCategory(doseRate) {
  // Map dose rate to safety words using legend thresholds
  if (doseRate <= 0.11) return 'legend_safe';
  if (doseRate <= 0.30) return 'legend_attention';
  return 'legend_danger';
}



// Get current URL params from map state
function getCurrentUrlParams() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  return `?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}`;
}

// Persist the last opened view so a fresh browser session resumes the same
// place and zoom, keeping orientation intuitive for returning visitors.
function saveMapViewState() {
  if (!map) return;
  try {
    const center = map.getCenter();
    const layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
    const state = {
      lat: center.lat,
      lon: center.lng,
      zoom: map.getZoom(),
      layer: layer
    };
    localStorage.setItem(mapViewStorageKey, JSON.stringify(state));
  } catch (err) {
    console.warn('save view failed', err);
  }
}

// Load previously saved coordinates/zoom/layer when available. Corrupted
// payloads simply fall back to null so first-run users stay on defaults.
function loadMapViewState() {
  try {
    const raw = localStorage.getItem(mapViewStorageKey);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (typeof parsed.lat !== 'number' || typeof parsed.lon !== 'number' || typeof parsed.zoom !== 'number') {
      return null;
    }
    return parsed;
  } catch (err) {
    console.warn('load view failed', err);
    return null;
  }
}

// Remember where the user actually is so we can reframe the map once
// radiation markers finish streaming in for the new viewport.
function setStoredUserCenter(lat, lon) {
  storedUserCenter = { lat: lat, lon: lon };
  waitForDangerFit = true;
}
    </script>

    <!-- Map initialization and markers -->
    <script>
      var map;
var circleMarkers = {};
var isTrackView = false;
var osmLayer, googleSatellite;
var trackBounds;
var currentTrackID = null;
var lastViewportKey = null;
var lastFilterState = null;  // Track filter state to detect changes

function getViewportKey() {
  // Create a string that uniquely identifies the current view
  // Rounded to reduce precision - small pans won't trigger full redraw
  const bounds = map.getBounds();
  const zoom = map.getZoom();
  const minLat = Math.round(bounds.getSouthWest().lat * 100) / 100;
  const minLon = Math.round(bounds.getSouthWest().lng * 100) / 100;
  const maxLat = Math.round(bounds.getNorthEast().lat * 100) / 100;
  const maxLon = Math.round(bounds.getNorthEast().lng * 100) / 100;
  return `${zoom}_${minLat}_${minLon}_${maxLat}_${maxLon}`;
}

function getFilterStateKey() {
  // Create a string that uniquely identifies the current filter state
  const state = loadSpeedFilterState();
  return JSON.stringify(state);
}
const shortLinkBox = document.getElementById('shortLinkDisplay');
let shortLinkTimer = null;
let shortLinkAbort = null;
let lastShortLinkFull = '';
let pendingShortLinkFull = '';
let shortLinkCommitPromise = null;
let shortLinkFocusDelayTimer = null;
let shortLinkPendingUrl = '';
let shortLinkFocusReady = (typeof document.hasFocus === 'function') ? document.hasFocus() : false;
const shortLinkIdleDelayMs = 1200;
const shortLinkFocusDelayMs = 900;
const mapViewStorageKey = 'cim.map.view.v1';
let storedUserCenter = null;
let waitForDangerFit = false;

/* ---------------------------------------------------------------
 *  refreshDownloadLink() toggles the track download button.
 *  We compute the href lazily so the button is only active when a
 *  track is selected, keeping the default map uncluttered.
 * ---------------------------------------------------------------*/
function refreshDownloadLink() {
  var link = document.getElementById('downloadTrackLink');
  var box  = document.querySelector('.download-track-container');
  if (!link || !box) {
    return;
  }
  if (currentTrackID) {
    link.href = '/api/track/' + currentTrackID + '.json';
    link.setAttribute('download', currentTrackID + '.json');
    box.style.display = 'block';
  } else {
    link.href = '#';
    link.removeAttribute('download');
    box.style.display = 'none';
  }
}

// New controller to cancel previous request
var markerStreamSource = null;

var liveHistoryCache = new Map();


/**
 * Load previously saved speed-filter state from sessionStorage.
 * If nothing is stored yet, return defaults that reflect backend capabilities.
 *   Realtime on:  Safecast heart on, ‚úàÔ∏è off, üöó on, üö∂ on  (as requested).
 *   Realtime off: ‚úàÔ∏è off, üöó on, üö∂ on  (heart absent).
 */
function loadSpeedFilterState() {
  // We derive defaults from the realtime flag so the UI matches backend capabilities.
  const base = { plane: false, car: true, ped: true };
  if (window.safecastRealtimeEnabled) {
    base.live = true;
  }
  try {
    const raw = sessionStorage.getItem('speedFilterState');
    const st = raw ? JSON.parse(raw) : {};
    const merged = Object.assign({}, base, st);
    if (!window.safecastRealtimeEnabled) {
      delete merged.live;
    }
    return merged;
  } catch (e) {
    return base;
  }
}

// ---------- helpers for time-range state ------------------------
function loadDateRangeState() {
  try { return JSON.parse(sessionStorage.getItem('dateRangeState')) || null; }
  catch(e){ return null; }
}
function saveDateRangeState(st) {
  sessionStorage.setItem('dateRangeState', JSON.stringify(st));
}

/**
 * Return a "Month YYYY" string in the browser locale.
 * Chrome/Firefox often display "Aug 2025",
 * Safari shows "Aug 2025", etc.
 */
function tsToNiceStr(ts){
  return new Date(ts * 1000)
    .toLocaleDateString(undefined, { month: 'short', year: 'numeric' });
}


// absolute month difference between two unix timestamps
function monthsApart(ts0, ts1){
  const d0 = new Date(ts0 * 1000);
  const d1 = new Date(ts1 * 1000);
  return Math.abs((d1.getFullYear() - d0.getFullYear()) * 12 +
    (d1.getMonth()     - d0.getMonth()));
}

/**
 * Persist current speed-filter state into sessionStorage
 * so the user‚Äôs choice is remembered for the whole session.
 */
function saveSpeedFilterState(state) {
  // Persist only supported options so stale realtime toggles do not leak between sessions.
  const toSave = Object.assign({}, state);
  if (!window.safecastRealtimeEnabled) {
    delete toSave.live;
  }
  sessionStorage.setItem('speedFilterState', JSON.stringify(toSave));
}

/**
 * Load unit preference from localStorage.
 * Returns 'uR' for microRoentgen or 'uSv' for microSievert.
 * Default is 'uR' for backward compatibility.
 */
function loadUnitPreference() {
  try {
    const stored = localStorage.getItem('unitPreference');
    return (stored === 'uSv') ? 'uSv' : 'uR';
  } catch (e) {
    return 'uR';
  }
}

/**
 * Save unit preference to localStorage.
 */
function saveUnitPreference(unit) {
  try {
    localStorage.setItem('unitPreference', unit);
  } catch (e) {
    console.error('Failed to save unit preference:', e);
  }
}

function saveColoringPreference(coloring) {
  try {
    localStorage.setItem('coloringPreference', coloring);
  } catch (e) {
    console.error('Failed to save coloring preference:', e);
  }
}

function loadColoringPreference() {
  try {
    return localStorage.getItem('coloringPreference') || 'safecast';
  } catch (e) {
    return 'safecast';
  }
}

// Global unit preference - initialized on page load
var currentUnit = loadUnitPreference();

/**
 * Update the legend display to show values in the current unit.
 * This updates both the range labels in the compact legend.
 */
function updateLegendDisplay() {
  var isUSv = (currentUnit === 'uSv');
  var unitLabel = document.getElementById('legend-unit-label');
  if (unitLabel) unitLabel.textContent = isUSv ? '¬µSv/h' : '¬µR/h';

  var bar = document.getElementById('legend-bar');
  var labelsContainer = document.getElementById('legend-labels');
  var legendBox = document.getElementById('legend');
  if (!bar || !labelsContainer || !legendBox) return;

  // Use local refs to ensure we have valid data
  var steps = (typeof currentColoring !== 'undefined' && currentColoring === 'chicha') ? schemeChicha : schemeSafecast;
  
  // Set height
  legendBox.style.height = (typeof currentColoring !== 'undefined' && currentColoring === 'chicha') ? '180px' : '500px';

  // Build gradient string manually for maximum compatibility
  var colorStrings = [];
  for (var i = 0; i < steps.length; i++) {
    colorStrings.push('rgb(' + steps[i].color.join(',') + ')');
  }
  
  // Apply gradient
  var gradientStyle = 'linear-gradient(to top, ' + colorStrings.join(', ') + ')';
  bar.style.backgroundImage = gradientStyle;
  bar.style.backgroundColor = '#333';
  bar.style.height = '100%';

  // Update labels
  labelsContainer.innerHTML = '';
  // Clone and reverse without spread for compatibility
  var stepsToRender = steps.slice().reverse();
  for (var j = 0; j < stepsToRender.length; j++) {
    var step = stepsToRender[j];
    var el = document.createElement('span');
    var val = step.uSv;
    if (!isUSv) {
       val = val * 100;
       if (val >= 100) val = Math.round(val);
       else if (val >= 10) val = parseFloat(val.toFixed(1));
       else val = parseFloat(val.toFixed(2));
    }
    el.textContent = val;
    labelsContainer.appendChild(el);
  }
}

/**
 * Attach a lightweight tooltip to a control so every hint shares one theme-aware renderer.
 * We return show/hide/destroy handlers to let callers reuse a single tooltip while controls collapse.
 */
function attachControlTooltip(target, options) {
  if (!target) {
    return {
      hide: function noopHide() {},
      destroy: function noopDestroy() {},
    };
  }

  const opts = Object.assign({
    placement: 'top',
    html: false,
    maxWidth: 280,
  }, options || {});

  let tooltipEl = null;

  function resolveContent() {
    const content = typeof opts.content === 'function' ? opts.content() : opts.content;
    return content || '';
  }

  function positionTooltip() {
    if (!tooltipEl || !target) {
      return;
    }
    const rect = target.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) {
      return;
    }
    const tipRect = tooltipEl.getBoundingClientRect();
    const margin = 10;
    let left = rect.left + (rect.width / 2) - (tipRect.width / 2);
    let top = rect.top - tipRect.height - margin;

    switch (opts.placement) {
      case 'bottom':
        top = rect.bottom + margin;
        left = rect.left + (rect.width / 2) - (tipRect.width / 2);
        break;
      case 'left':
        left = rect.left - tipRect.width - margin;
        top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        break;
      case 'right':
        left = rect.right + margin;
        top = rect.top + (rect.height / 2) - (tipRect.height / 2);
        break;
      default:
        // keep default top placement
        break;
    }

    const viewportPadding = 8;
    left = Math.max(viewportPadding, Math.min(left, window.innerWidth - tipRect.width - viewportPadding));
    top = Math.max(viewportPadding, Math.min(top, window.innerHeight - tipRect.height - viewportPadding));
    tooltipEl.style.left = left + 'px';
    tooltipEl.style.top = top + 'px';
  }

  function showTooltip() {
    if (!target || !target.isConnected) {
      return;
    }
    const rects = target.getClientRects();
    if (!rects || rects.length === 0) {
      return;
    }
    const content = resolveContent();
    if (!content) {
      return;
    }
    if (tooltipEl) {
      if (opts.html) {
        tooltipEl.innerHTML = content;
      } else {
        tooltipEl.textContent = content;
      }
      positionTooltip();
      return;
    }
    tooltipEl = document.createElement('div');
    tooltipEl.className = 'control-tooltip';
    tooltipEl.setAttribute('role', 'tooltip');
    const maxWidth = typeof opts.maxWidth === 'number' ? opts.maxWidth + 'px' : opts.maxWidth;
    tooltipEl.style.maxWidth = maxWidth;
    if (opts.html) {
      tooltipEl.innerHTML = content;
    } else {
      tooltipEl.textContent = content;
    }
    document.body.appendChild(tooltipEl);
    positionTooltip();
    window.addEventListener('scroll', positionTooltip, true);
    window.addEventListener('resize', positionTooltip);
    requestAnimationFrame(function () {
      if (tooltipEl) {
        tooltipEl.classList.add('control-tooltip--visible');
      }
    });
  }

  function hideTooltip() {
    if (!tooltipEl) {
      return;
    }
    window.removeEventListener('scroll', positionTooltip, true);
    window.removeEventListener('resize', positionTooltip);
    const el = tooltipEl;
    tooltipEl = null;
    el.classList.remove('control-tooltip--visible');
    setTimeout(function () {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    }, 150);
  }

  function destroyTooltip() {
    hideTooltip();
    target.removeEventListener('mouseenter', showTooltip);
    target.removeEventListener('mouseleave', hideTooltip);
    target.removeEventListener('focus', showTooltip);
    target.removeEventListener('blur', hideTooltip);
    target.removeEventListener('keydown', onKeyDown);
  }

  function onKeyDown(ev) {
    if (ev.key === 'Escape') {
      hideTooltip();
    }
  }

  target.addEventListener('mouseenter', showTooltip);
  target.addEventListener('mouseleave', hideTooltip);
  target.addEventListener('focus', showTooltip);
  target.addEventListener('blur', hideTooltip);
  target.addEventListener('keydown', onKeyDown);

  return {
    show: showTooltip,
    hide: hideTooltip,
    destroy: destroyTooltip,
  };
}


document.addEventListener('DOMContentLoaded', function () {

  // Initialize trackID from path
  var match = window.location.pathname.match(/^\/trackid\/([a-zA-Z0-9]+)/);
  if (match) {
    currentTrackID = match[1];
    isTrackView = true;
    // NEW: show back button immediately
    var backBox = document.querySelector('.back-to-all-container');
    if (backBox) backBox.style.display = 'block';
  }
  refreshDownloadLink();

  // Theme-aware hover hints keep visitors oriented without repeating markup titles.
  var uploadLabel = document.querySelector('.upload-btn');
  attachControlTooltip(uploadLabel, {
    placement: 'left',
    content: function () { return translate('upload_button_tooltip'); },
    maxWidth: 320,
  });

  var locateBtn = document.getElementById('locateButton');
  attachControlTooltip(locateBtn, {
    placement: 'left',
    content: function () { return translate('locate_button_tooltip'); },
  });

  var qrBtn = document.getElementById('qrButton');
  attachControlTooltip(qrBtn, {
    placement: 'left',
    content: function () { return translate('qr_button_tooltip'); },
  });

  var themeToggle = document.getElementById('themeToggle');
  attachControlTooltip(themeToggle, {
    placement: 'left',
    content: function () { return translate('theme_toggle_tooltip'); },
    maxWidth: 260,
  });

  var shortLink = document.getElementById('shortLinkDisplay');
  if (shortLink) {
    var shortLinkHandle = attachControlTooltip(shortLink, {
      placement: 'bottom',
      content: function () { return translate('short_link_tooltip'); },
      maxWidth: 260,
    });
    window.__hideShortLinkHint = shortLinkHandle.hide;
  }

  var legendBox = document.getElementById('legend');
  if (legendBox) {
    var legendHandle = attachControlTooltip(legendBox, {
      placement: 'left',
      content: function () { 
        var key = (typeof currentColoring !== 'undefined' && currentColoring === 'chicha') 
          ? 'legend_button_tooltip_chicha' 
          : 'legend_button_tooltip_safecast';
        var txt = translate(key);
        // Fallback if translations not reloaded
        if (txt === key) {
          return (key === 'legend_button_tooltip_chicha') 
            ? "Chicha radiation safety legend" 
            : "Safecast radiation safety legend";
        }
        return txt;
      },
      maxWidth: 300,
    });
    window.__hideLegendHint = legendHandle.hide;
    legendBox.addEventListener('keydown', function (ev) {
      if (ev.key === 'Enter' || ev.key === ' ') {
        ev.preventDefault();
        openLegendModal();
      }
    });
  }

  var githubLink = document.querySelector('.github-link');
  if (githubLink) {
    var githubHandle = attachControlTooltip(githubLink, {
      placement: 'top',
      html: true,
      maxWidth: 320,
      content: function () {
        var version = '{{ .Version }}';
        var title = translate('github_link_tooltip_title');
        var desc = translate('github_link_tooltip_desc');
        var versionText = translate('github_link_tooltip_version');
        if (typeof versionText === 'string' && versionText.indexOf('{version}') !== -1) {
          versionText = versionText.replace('{version}', version);
        }
        return '<div class="control-tooltip__title">' + title + '</div>' +
          '<div>' + desc + '</div>' +
          '<div class="control-tooltip__meta">' + versionText + '</div>';
      },
    });
    window.__hideGithubHint = githubHandle.hide;
    githubLink.addEventListener('click', function () {
      githubHandle.hide();
    });
  }

  // Initialize layers and auto theme switch
  const media = window.matchMedia('(prefers-color-scheme: dark)');
  const osmLight = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  const osmDark  = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  window.osmLight = osmLight; // expose for theme toggle
  window.osmDark  = osmDark;  // expose for theme toggle
  // Google tiles always use satellite imagery for consistent look
  const googleSat   = 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}';

  osmLayer = L.tileLayer(media.matches ? osmDark : osmLight, {
    maxZoom: 18,
    attribution: '&copy; OSM contributors'
  });

  // Use the same satellite layer regardless of theme
  googleSatellite = L.tileLayer(googleSat, {
    maxZoom: 20,
    attribution: '&copy; Google'
  });

  // right after creating osmLayer and googleSatellite
  const urlParams       = new URLSearchParams(window.location.search);
  const startLayerName  = decodeURIComponent(urlParams.get('layer') || defaultCfg.layer);
  const startLayer      = startLayerName === 'Google Satellite' ? googleSatellite : osmLayer;

  map = L.map('map', {
    center: [defaultCfg.lat, defaultCfg.lon],
    zoom  : defaultCfg.zoom,
    layers: [startLayer],           // only one base layer
  });

  // Layer control
  var baseLayers = {
    "OpenStreetMap": osmLayer,
    "Google Satellite": googleSatellite
  };

  L.control.layers(baseLayers, null, {
    position: 'topleft',
    collapsed: false
  }).addTo(map);

  // Add custom attribution links that open informative popups
  map.attributionControl.addAttribution(
		'<a href="#" class="attr-link" data-info="api">' + translate('attr_api') + '</a> | ' + 
    '<a href="#" class="attr-link" data-info="legal">' + translate('attr_legal') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="sources">' + translate('attr_sources') + '</a> | ' +
    '<a href="#" class="attr-link" data-info="license">' + translate('attr_license') + '</a>'
  );

  // Track view initialization
  // Inject markers as literal JSON so the first render avoids the template parse error
  // and the frontend can inspect the slice immediately.
  var initialMarkers = {{ .MarkersJSON }};
  if (Array.isArray(initialMarkers) && initialMarkers.length > 0) {
    isTrackView = true;

    // Don't show initialMarkers immediately; load them in parts via get_markers
    map.on('load', debounceUpdateMarkers);

    // Adjust marker size on zoom
    map.on('zoomend', function() {
      invalidateMarkerStyleCache();  // Clear style cache on zoom
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
  } else {
    // Dynamic marker updates in global mode
    map.on('load', debounceUpdateMarkers);
    map.on('zoomend', function() {
      adjustMarkerRadius();
      debounceUpdateMarkers();
    });
    map.on('moveend', debounceUpdateMarkers);
    debounceUpdateMarkers;
  }

  // Load map state from URL
  loadMapFromUrl();

  // Update URL on map changes
  map.on('baselayerchange', updateUrl);
  map.on('moveend', updateUrl);
  map.on('zoomend', updateUrl);

  // Initialize UI elements
  initializeUIElements();

  // Periodically refresh realtime styling so markers fade without map motion.
  setInterval(adjustMarkerRadius, 60 * 1000);

  /**
   * Build a Leaflet control with three check-boxes that filter markers
   * by recorded speed. Labels now show speed in km/h instead of m/s.
   * Default state (when realtime exists): Safecast heart on, ‚úàÔ∏è off, üöó on, üö∂ on.
   */
  function createSpeedFilterControls() {

    if (isTrackView) return;   // hidden in track view

    // load previously saved state (or defaults)
    const state = loadSpeedFilterState();

    // custom Leaflet control
    const SpeedCtrl = L.Control.extend({
      onAdd() {
        const div = L.DomUtil.create('div', 'leaflet-control-layers');
        div.style.padding = '6px 10px';

        // helper that returns one <label> line
        const row = (id, iconMarkup, checked, extraClass = '') => `
            <label style="white-space:nowrap;display:block;cursor:pointer;">
            <input id="${id}" type="checkbox" ${checked ? 'checked' : ''}/>
            <span class="speed-filter-icon ${extraClass}">${iconMarkup}</span>
            </label>`;

        // Build rows dynamically so the realtime checkbox only appears when supported server-side.
        const pieces = [];
        if (window.safecastRealtimeEnabled) {
          // Use the Safecast heart artwork so the live toggle reflects the new branding.
          const liveIconMarkup = '<img src="/static/images/safecast-heart-logo.png" alt="Realtime measurements from safecast.org" style="width:1em; height:1em; vertical-align:middle;"/>';
          pieces.push(row('sfLive', liveIconMarkup, state.live));
          pieces.push('<div class="leaflet-control-layers-separator"></div>');
        }
        pieces.push(
          row('sfPlane', '‚úàÔ∏è', state.plane, 'speed-filter-icon--mono'),
          row('sfCar',   'üöó', state.car,   'speed-filter-icon--mono'),
          row('sfPed',   'üö∂', state.ped,   'speed-filter-icon--mono')
        );
        div.innerHTML = pieces.join('');

        // We collect all checkboxes so keyboard focus and pointer use can share a single tooltip instance.
        const checkboxes = Array.from(div.querySelectorAll('input[type=checkbox]'));

        // Attach an explanatory tooltip so visitors understand how each checkbox slices the dataset by speed.
        const speedTooltipHandle = attachControlTooltip(div, {
          placement: 'right',
          html: true,
          maxWidth: 340,
          content: function () {
            const title = translate('speed_filter_tooltip_title');
            const intro = translate('speed_filter_tooltip_intro');
            const accuracy = translate('speed_filter_tooltip_accuracy');
            const lines = [];
            if (window.safecastRealtimeEnabled) {
              lines.push(translate('speed_filter_tooltip_live'));
            }
            lines.push(translate('speed_filter_tooltip_plane'));
            lines.push(translate('speed_filter_tooltip_car'));
            lines.push(translate('speed_filter_tooltip_ped'));
            const listHtml = lines.map(function (line) {
              return '<li>' + line + '</li>';
            }).join('');
            return '<div class="control-tooltip__title">' + title + '</div>' +
              '<div>' + intro + '</div>' +
              '<ul class="control-tooltip__list">' + listHtml + '</ul>' +
              '<div class="control-tooltip__meta">' + accuracy + '</div>';
          },
        });

        // Keyboard users focus the individual checkboxes, so we mirror the combined tooltip when inputs gain focus.
        checkboxes.forEach(cb => {
          cb.addEventListener('focus', () => {
            if (speedTooltipHandle && typeof speedTooltipHandle.show === 'function') {
              speedTooltipHandle.show();
            }
          });
          cb.addEventListener('blur', () => {
            if (speedTooltipHandle && typeof speedTooltipHandle.hide === 'function') {
              speedTooltipHandle.hide();
            }
          });
        });

        // prevent map drag/zoom while clicking inside the control
        L.DomEvent.disableClickPropagation(div);

        // attach change-handlers
        checkboxes.forEach(cb => {
          cb.addEventListener('change', () => {
            if (window.safecastRealtimeEnabled) {
              state.live = div.querySelector('#sfLive').checked;
            } else {
              delete state.live;
            }
            state.plane = div.querySelector('#sfPlane').checked;
            state.car   = div.querySelector('#sfCar').checked;
            state.ped   = div.querySelector('#sfPed').checked;
            saveSpeedFilterState(state);   // remember choice
            debounceUpdateMarkers();       // redraw with new filter
          });
        });

        return div;
      }
    });

    new SpeedCtrl({ position: 'topleft' }).addTo(map);
  }



  // Call it
  createSpeedFilterControls();   
  createDateRangeSlider();



});


/**
 * Date-range control with two modes:
 *  - YEAR (single handle): labels show full [minYear..maxYear] when NO user filter is active,
 *    otherwise they show the chosen year.
 *  - MONTH (double handle): classic [from..to] range.
 *
 * Key ideas:
 *  ‚Ä¢ We expose window.__setDateSliderVisibility(show)
 *  ‚Ä¢ We expose window.__initSliderOnce(minTs,maxTs) for first build
 *  ‚Ä¢ We expose window.__syncDateSliders(minTs,maxTs) to keep ranges/labels
 *    in sync with the current map viewport on every pan/zoom IF no custom
 *    time filter is set by the user.
 *
 * No globals except 3 window.* hooks; no vendor APIs beyond noUiSlider.
 */
function createDateRangeSlider(){

  if (isTrackView) return;   // no date control in single-track mode

  let sliderBox, yearSlider, monthSlider;
  let mode  = 'year';                // 'year' | 'month'
  let initY = false, initM = false;  // lazy init flags
  let sliderTooltipHandle = null;    // tooltip helper for hover hints

  // We store the "full range" of current viewport to detect
  // whether a saved filter is actually "show all".
  let fullRange = null; // [minTs,maxTs]

  const DateCtrl = L.Control.extend({
    onAdd(){
      sliderBox = L.DomUtil.create('div','leaflet-control-layers date-slider-box');
      sliderBox.style.display = 'none'; // hidden until needed
      sliderBox.innerHTML = `
        <div class="slider-toggle">
          <button id="btnYear"  class="active">Y</button>
          <button id="btnMonth">M</button>
        </div>
        <div id="lblMax" class="slider-label"></div>
        <div id="yearSlider"></div>
        <div id="dateSlider"></div>
        <div id="lblMin" class="slider-label"></div>
        <button id="btnReset" class="slider-reset-btn" title="Reset"> ‚ü≤ </button>
      `;
      sliderBox.setAttribute('role', 'group');
      sliderBox.setAttribute('tabindex', '0');
      sliderBox.setAttribute('aria-label', translate('date_slider_tooltip'));
      sliderTooltipHandle = attachControlTooltip(sliderBox, {
        placement: 'right',
        content: function () { return translate('date_slider_tooltip'); },
        maxWidth: 300,
      });
      return sliderBox;
    }
  });
  new DateCtrl({ position:'topleft' }).addTo(map);

  const btnY = sliderBox.querySelector('#btnYear');
  const btnM = sliderBox.querySelector('#btnMonth');
  const btnReset = sliderBox.querySelector('#btnReset');
  const lblMin = () => sliderBox.querySelector('#lblMin');
  const lblMax = () => sliderBox.querySelector('#lblMax');

  btnY.onclick = () => switchMode('year');
  btnM.onclick = () => switchMode('month');

  // Show/hide the whole control (called from updateMarkers())
  window.__setDateSliderVisibility = (show)=>{
    sliderBox.style.display = show ? 'block' : 'none';
    if(!show) sessionStorage.removeItem('dateRangeState');
    if (!show && sliderTooltipHandle) {
      sliderTooltipHandle.hide();
    }
  };

  // One-time creation of both sliders using initial bounds
  window.__initSliderOnce = (minTs,maxTs)=>{
    if (initY && initM) return;
    fullRange = [minTs,maxTs]; // remember initial "full range"

    // YEAR slider (single handle)
    if(!initY){
      yearSlider = sliderBox.querySelector('#yearSlider');
      const minYear = new Date(minTs*1000).getUTCFullYear();
      const maxYear = new Date(maxTs*1000).getUTCFullYear();

      noUiSlider.create(yearSlider,{
        start      : minYear,                // the handle can sit anywhere; labels decide what to show
        connect    : [true,false],
        orientation: 'vertical',
        direction  : 'rtl',
        step       : 1,
        range      : { min:minYear, max:maxYear },
        format     : wNumb({ decimals:0 })
      });

      // Update labels:
      //  - If NO user filter or filter equals fullRange ‚Üí show full year bounds.
      //  - Else ‚Üí show the chosen year.
      yearSlider.noUiSlider.on('update', ([y])=>{
        if (mode !== 'year') return;
        const saved = loadDateRangeState();
        const fr = fullRange || [minTs,maxTs];
        const isFull = !saved || (saved[0] === fr[0] && saved[1] === fr[1]);
        if (isFull){
          const r = yearSlider.noUiSlider.options.range;
          lblMin().textContent = r.min;
          lblMax().textContent = r.max;
        } else {
          lblMin().textContent = y;
          lblMax().textContent = y;
        }
      });
      yearSlider.noUiSlider.on('change', updateDateFilter);
      initY = true;
    }

    // MONTH slider (double handle)
    if(!initM){
      monthSlider = sliderBox.querySelector('#dateSlider');
      noUiSlider.create(monthSlider,{
        start       : [minTs,maxTs],
        connect     : true,
        orientation : 'vertical',
        direction   : 'rtl',
        step        : 3600, // 1 hour
        range       : { min:minTs, max:maxTs },
        format      : wNumb({ decimals:0 })
      });
      monthSlider.noUiSlider.on('update', ()=>{
        if (mode !== 'month') return;
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      });
      monthSlider.noUiSlider.on('change', updateDateFilter);
      monthSlider.style.display = 'none';
      initM = true;
    }

    // Initial labels = full bounds
    if (mode === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      lblMin().textContent = r.min;
      lblMax().textContent = r.max;
    } else {
      lblMin().textContent = tsToNiceStr(minTs);
      lblMax().textContent = tsToNiceStr(maxTs);
    }
  };

  // Sync ranges and labels to the *current* viewport on every pan/zoom,
  // but ONLY when user has not applied a custom time filter.
  window.__syncDateSliders = (minTs,maxTs)=>{
    if (!initY || !initM) return; // not built yet

    // Detect whether user has a custom time filter (not full range).
    const saved = loadDateRangeState();
    const prevFull = fullRange;
    fullRange = [minTs,maxTs]; // update "full" range to the new viewport

    const hasCustom =
      !!saved && !(saved[0] === prevFull?.[0] && saved[1] === prevFull?.[1]) &&
      !(saved[0] === fullRange[0] && saved[1] === fullRange[1]);

    // Update YEAR slider bounds
    const minYear = new Date(minTs*1000).getUTCFullYear();
    const maxYear = new Date(maxTs*1000).getUTCFullYear();
    yearSlider.noUiSlider.updateOptions({
      range: { min:minYear, max:maxYear }
    }, false);

    // Update MONTH slider bounds
    monthSlider.noUiSlider.updateOptions({
      range: { min:minTs, max:maxTs }
    }, false);

    // If no custom filter ‚Üí force labels to show full bounds and make month slider span all
    if (!hasCustom){
      if (mode === 'year'){
        const r = yearSlider.noUiSlider.options.range;
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        monthSlider.noUiSlider.set([minTs,maxTs]);
        lblMin().textContent = tsToNiceStr(minTs);
        lblMax().textContent = tsToNiceStr(maxTs);
      }
      // persist that "no filter" means full range
      saveDateRangeState([minTs,maxTs]);
    }
  };

  // Reset button ‚Üí drop custom filter and show full bounds of the *current* viewport
  btnReset.onclick = ()=>{
    sessionStorage.removeItem('dateRangeState');
    if (initY && initM){
      const rY = yearSlider.noUiSlider.options.range;
      const rM = monthSlider.noUiSlider.options.range;
      yearSlider.noUiSlider.set(rY.min);      // handle position is cosmetic
      monthSlider.noUiSlider.set([rM.min, rM.max]);

      lblMin().textContent = (mode==='year') ? rY.min : tsToNiceStr(rM.min);
      lblMax().textContent = (mode==='year') ? rY.max : tsToNiceStr(rM.max);

      // remember "no filter" == full range of the viewport
      saveDateRangeState([rM.min, rM.max]);
      debounceUpdateMarkers();
    }
  };

  function switchMode(next){
    if (mode === next) return;

    mode = next;
    btnY.classList.toggle('active', next==='year');
    btnM.classList.toggle('active', next==='month');
    yearSlider.style.display  = next==='year'  ? 'block' : 'none';
    monthSlider.style.display = next==='month' ? 'block' : 'none';

    // Refresh labels on mode switch respecting full/custom state
    const saved = loadDateRangeState();
    const fr = fullRange;
    const isFull = !saved || (fr && saved[0]===fr[0] && saved[1]===fr[1]);

    if (next === 'year'){
      const r = yearSlider.noUiSlider.options.range;
      if (isFull){
        lblMin().textContent = r.min;
        lblMax().textContent = r.max;
      } else {
        const y = +yearSlider.noUiSlider.get();
        lblMin().textContent = y;
        lblMax().textContent = y;
      }
    } else {
      const r = monthSlider.noUiSlider.options.range;
      if (isFull){
        monthSlider.noUiSlider.set([r.min, r.max]);
        lblMin().textContent = tsToNiceStr(r.min);
        lblMax().textContent = tsToNiceStr(r.max);
      } else {
        const [v0, v1] = monthSlider.noUiSlider.get().map(Number);
        lblMin().textContent = tsToNiceStr(v0);
        lblMax().textContent = tsToNiceStr(v1);
      }
    }

    // Do not change filter on mode flip; user intent remains the same
  }

  function updateDateFilter(){
    // YEAR mode ‚Üí make a full [year..year] month span
    if (mode==='year'){
      const y = +yearSlider.noUiSlider.get();
      const from = Date.UTC(y,0,1)/1000;
      const to   = Date.UTC(y+1,0,1)/1000 - 1;
      saveDateRangeState([from,to]);
    } else {
      saveDateRangeState(monthSlider.noUiSlider.get().map(Number));
    }
    debounceUpdateMarkers();
  }
}



// Function definitions

// ---------- Marker popups and tooltips ----------
// Build HTML once so popups and tooltips share identical content.
  function buildLiveMarkerPopup(marker) {
    const doseRate = marker.doseRate || 0;
    const primaryValue = formatPrimaryUnit(doseRate);
    const secondaryValue = formatSecondaryUnit(doseRate);
    const primaryUnit = getPrimaryUnitLabel();
    const secondaryUnit = getSecondaryUnitLabel();
    const doseColor = getGradientColor(doseRate);
    const statusKey = doseCategory(doseRate);
    const statusLabel = translate(statusKey);
    const statusTextColor = isDarkColor(doseColor) ? '#ffffff' : '#000000';
    const lastSeen = formatDateTime(marker.date);
    const local = approximateLocalTime(marker.lat, marker.lon);
    const extrasRaw = (marker.liveExtra && typeof marker.liveExtra === 'object') ? marker.liveExtra : null;
    const extrasCopy = extrasRaw ? Object.assign({}, extrasRaw) : {};

    const climateParts = [];
    if (extrasRaw) {
      if (typeof extrasRaw.temperature_c === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_temperature'))}: ${escapeHtml(formatExtraValue('temperature_c', extrasRaw.temperature_c))}`);
        delete extrasCopy.temperature_c;
      } else if (typeof extrasRaw.temperature_f === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_temperature_f'))}: ${escapeHtml(formatExtraValue('temperature_f', extrasRaw.temperature_f))}`);
        delete extrasCopy.temperature_f;
      }
      if (typeof extrasRaw.humidity_percent === 'number') {
        climateParts.push(`${escapeHtml(translate('live_marker_humidity'))}: ${escapeHtml(formatExtraValue('humidity_percent', extrasRaw.humidity_percent))}`);
        delete extrasCopy.humidity_percent;
      }
    }

    const climateHtml = climateParts.length ? `<div class="live-popup-climate">${climateParts.join(' ¬∑ ')}</div>` : '';
    const extrasBlock = renderLiveExtras(extrasCopy);
    const deviceID = marker.deviceID || (marker.trackID ? marker.trackID.replace(/^live:/, '') : '');
    const attrs = [];
    if (deviceID) attrs.push(`data-device="${escapeHtml(deviceID)}"`);
    if (marker.deviceName) attrs.push(`data-name="${escapeHtml(marker.deviceName)}"`);
    if (marker.transport) attrs.push(`data-transport="${escapeHtml(marker.transport)}"`);
    if (marker.tube) attrs.push(`data-tube="${escapeHtml(marker.tube)}"`);
    if (marker.country) attrs.push(`data-country="${escapeHtml(marker.country)}"`);
    if (typeof marker.lat === 'number') attrs.push(`data-lat="${marker.lat}"`);
    if (typeof marker.lon === 'number') attrs.push(`data-lon="${marker.lon}"`);
    const chartLink = deviceID ? `<div><a href="#" class="live-chart-link live-popup-small-link" ${attrs.join(' ')}>${translate('live_marker_chart_link')}</a></div>` : '';

    const metaBits = [];
    metaBits.push(`<div><strong>${translate('live_marker_last_seen')}:</strong> ${escapeHtml(lastSeen)}</div>`);
    if (local) {
      metaBits.push(`<div><strong>${translate('live_marker_local_time')}:</strong> ${escapeHtml(local.text)} (${escapeHtml(local.zone)})</div>`);
    }
    const deviceMeta = buildDeviceMeta(marker);
    if (deviceMeta) metaBits.push(deviceMeta);
    if (extrasBlock) metaBits.push(extrasBlock);
    if (chartLink) metaBits.push(chartLink);
    const metaHtmlBlock = metaBits.length ? `<div class="live-popup-meta">${metaBits.join('')}</div>` : '';

    const statusHtml = (typeof currentColoring !== 'undefined' && currentColoring === 'chicha')
      ? `<div class="live-popup-dose-status" style="background:${doseColor};color:${statusTextColor};">
           <a href="#" class="risk-link" style="color:${statusTextColor};">${escapeHtml(statusLabel)}</a>
         </div>`
      : '';

    return `
      <div class="custom-tooltip live-tooltip">
        <div class="live-tooltip-header">
          <img src="/static/images/safecast-heart-logo.png" alt="Safecast realtime" class="live-tooltip-heart">
          <div>
            <div class="live-tooltip-title">${translate('live_marker_title')}</div>
            <p class="live-tooltip-desc">${describeLiveSensor(marker)}</p>
          </div>
        </div>
        <div class="live-popup-dose">
          <div class="live-popup-dose-primary" style="color:${doseColor};">
            ${primaryValue}<span class="live-popup-dose-unit">${primaryUnit}</span>
          </div>
          <div class="live-popup-dose-secondary" style="color:${doseColor};">
            ${secondaryValue} ${secondaryUnit}
          </div>
          ${statusHtml}
        </div>
        ${climateHtml}
        ${metaHtmlBlock}
      </div>`;
  }

  function buildMarkerContent(marker) {
    if (marker.speed < 0) {
      return buildLiveMarkerPopup(marker);
    }

    const speedText = (typeof marker.speed === 'number' && isFinite(marker.speed))
      ? `${(marker.speed * 3.6).toFixed(1)} km/h`
      : '‚Äî';

    const hasSpectrum = marker.hasSpectrum || false;
    const markerId = marker.id || marker.markerId;
    const spectrumSection = hasSpectrum ? `
        <hr style="margin: 8px 0; border-top: 1px solid #ccc;">
        <div><strong>üìä Gamma Spectrum</strong></div>
        <div id="spectrum-container-${markerId}" style="margin-top: 8px;">
          <canvas id="spectrum-chart-${markerId}" style="max-height: 250px;"></canvas>
          <div style="margin-top: 8px; text-align: center;">
            <button onclick="downloadSpectrum(${markerId}, 'json')" style="margin: 2px; padding: 4px 8px;">Download JSON</button>
            <button onclick="downloadSpectrum(${markerId}, 'csv')" style="margin: 2px; padding: 4px 8px;">Download CSV</button>
          </div>
        </div>` : '';

    const primaryValue = formatPrimaryUnit(marker.doseRate);
    const secondaryValue = formatSecondaryUnit(marker.doseRate);
    const primaryUnit = getPrimaryUnitLabel();
    const secondaryUnit = getSecondaryUnitLabel();

    const statusHtml = (typeof currentColoring !== 'undefined' && currentColoring === 'chicha')
      ? ` (<a href="#" class="risk-link">${translate(doseCategory(marker.doseRate))}</a>)`
      : '';

    return `
      <div class="custom-tooltip">
        <div><strong>${translate('radiation_dose')}:</strong><br>
          ${primaryValue} ${primaryUnit} (${secondaryValue} ${secondaryUnit})
          ${statusHtml}
        </div>
        <div><strong>${translate('speed')}:</strong> ${speedText}</div>
        <div style="margin-top:4px">
          <!-- clicking the link switches to track mode -->
          <a href="#" class="track-link" data-track="${marker.trackID}" style="font-weight:bold;">
            ${translate('track_id')}: ${marker.trackID}
          </a>
        </div>
        ${spectrumSection}
      </div>`;
  }

// Popup reuses shared builder to stay in sync with tooltips.
function getPopupContent(marker) {
  return buildMarkerContent(marker);
}

// Tooltip uses the same builder for hover previews.
function getTooltipContent(marker) {
  return buildMarkerContent(marker);
}


/* ============================================
 * TILE CACHE - Client-side marker data cache
 * ============================================ */
const tileCache = {
  cache: new Map(),
  maxSize: 100, // Cache up to 100 tiles
  ttl: 5 * 60 * 1000, // 5 minutes

  makeKey(zoom, minLat, minLon, maxLat, maxLon) {
    // Round coordinates to reduce cache key variations
    const precision = zoom >= 10 ? 4 : 3;
    return `${zoom}_${minLat.toFixed(precision)}_${minLon.toFixed(precision)}_${maxLat.toFixed(precision)}_${maxLon.toFixed(precision)}`;
  },

  get(key) {
    const entry = this.cache.get(key);
    if (!entry) return null;

    // Check if expired
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    entry.lastAccess = Date.now();
    return entry.data;
  },

  set(key, data) {
    // Implement LRU eviction
    if (this.cache.size >= this.maxSize) {
      // Remove oldest accessed entry
      let oldestKey = null;
      let oldestTime = Infinity;
      for (const [k, v] of this.cache.entries()) {
        if (v.lastAccess < oldestTime) {
          oldestTime = v.lastAccess;
          oldestKey = k;
        }
      }
      if (oldestKey) this.cache.delete(oldestKey);
    }

    this.cache.set(key, {
      data: data,
      timestamp: Date.now(),
      lastAccess: Date.now()
    });
  },

  clear() {
    this.cache.clear();
  }
};

/* ===== MARKER BATCHING SYSTEM ===== */
const markerBatch = [];
const BATCH_SIZE = 25;
let batchFlushTimer = null;

function flushMarkerBatch(fromDone = false) {
  if (batchFlushTimer) {
    clearTimeout(batchFlushTimer);
    batchFlushTimer = null;
  }
  
  if (markerBatch.length === 0) return;
  
  // Use FeatureGroup to batch DOM operations
  const batch = L.featureGroup();
  const toAdd = markerBatch.splice(0, markerBatch.length);
  
  toAdd.forEach(entry => {
    batch.addLayer(entry.marker);
    circleMarkers[entry.id] = entry.marker;
  });
  
  batch.addTo(map);
  
  // Schedule next flush if more markers queued
  if (markerBatch.length > 0) {
    batchFlushTimer = setTimeout(flushMarkerBatch, 10);
  }
}

function queueMarkerForBatch(marker, id) {
  markerBatch.push({ marker, id });
  
  if (markerBatch.length >= BATCH_SIZE) {
    flushMarkerBatch();
  } else if (!batchFlushTimer) {
    batchFlushTimer = setTimeout(flushMarkerBatch, 50);
  }
}
/* ===== END BATCHING ===== */

// ===== MARKER STYLE CACHE =====
// Reduces recalculation of styles for markers with similar properties
const markerStyleCache = new Map();
let lastStyleCacheZoom = null;

function getCachedMarkerStyle(doseRate, zoom, speed) {
  // Create cache key using reduced precision to increase hit rate
  // Round doseRate to 3 decimals, speed to 1 decimal
  const doseKey = Math.round(doseRate * 1000);
  const speedKey = Math.round(speed * 10);
  const cacheKey = `${doseKey}_${zoom}_${speedKey}`;
  
  if (markerStyleCache.has(cacheKey)) {
    return markerStyleCache.get(cacheKey);
  }
  
  // Calculate and cache
  const style = {
    radius: getRadius(doseRate, zoom),
    fillColor: getGradientColor(doseRate),
    color: getGradientColor(doseRate),
    weight: 0,
    opacity: getFillOpacity(speed),
    fillOpacity: getFillOpacity(speed)
  };
  
  markerStyleCache.set(cacheKey, style);
  return style;
}

// Clear cache when zoom changes
function invalidateMarkerStyleCache() {
  if (lastStyleCacheZoom !== map.getZoom()) {
    markerStyleCache.clear();
    lastStyleCacheZoom = map.getZoom();
  }
}
// ===== END CACHE =====

/* Request markers for current bounds/zoom, render them,
 * and keep the date sliders in sync with the viewport.
 */
function updateMarkers(){
  const loadingEl = document.getElementById('loadingOverlay');
  if (loadingEl) loadingEl.style.display='block';

  if (markerStreamSource) markerStreamSource.close();
  if (window.markerStreamSources) {
    window.markerStreamSources.forEach(source => source.close());
  }
  window.markerStreamSources = [];

  const zoom   = map.getZoom();
  const bounds = map.getBounds();

  const baseParams = {
    zoom  : zoom,
    minLat: bounds.getSouthWest().lat,
    minLon: bounds.getSouthWest().lng,
    maxLat: bounds.getNorthEast().lat,
    maxLon: bounds.getNorthEast().lng
  };

  // When viewing a specific track, use world bounds to load ALL markers, not just viewport
  if (currentTrackID) {
    baseParams.trackID = currentTrackID;
    baseParams.minLat = -90;
    baseParams.minLon = -180;
    baseParams.maxLat = 90;
    baseParams.maxLon = 180;
  }

  const savedRange = loadDateRangeState();

  // Skip if viewport hasn't meaningfully changed (prevents unnecessary redraws)
  const newViewportKey = getViewportKey();
  const newFilterState = getFilterStateKey();
  const filterChanged = lastFilterState !== newFilterState;
  
  if (lastViewportKey === newViewportKey && lastFilterState === newFilterState && !currentTrackID) {
    // Viewport and filters unchanged in global view - skip full redraw
    return;
  }
  lastViewportKey = newViewportKey;
  lastFilterState = newFilterState;  // Track filter state to detect future changes

  // If filters changed, clear all markers to re-filter them
  if (filterChanged) {
    // Flush any pending batched markers first
    flushMarkerBatch();
    // Remove all markers from map
    for (const key in circleMarkers) {
      const marker = circleMarkers[key];
      map.removeLayer(marker);
    }
    circleMarkers = {};
  } else {
    // Otherwise, remove only markers that are now off-screen
    const markersToRemove = [];
    
    for (const key in circleMarkers) {
      const marker = circleMarkers[key];
      if (marker.getLatLng && !bounds.contains(marker.getLatLng())) {
        map.removeLayer(marker);
        markersToRemove.push(key);
      }
    }
    
    markersToRemove.forEach(key => {
      delete circleMarkers[key];
    });
  }

  const tracks = new Set();
  let minTs = Infinity, maxTs = -Infinity;

  // PARALLEL TILE-BASED LOADING WITH CACHING
  // Split viewport into 2x2 grid (4 tiles) and fetch in parallel
  // Cache enabled for all zoom levels (except track view)
  // Disable during background refresh to reduce database load
  const useTiles = !currentTrackID && !window.isBackgroundRefresh; // Use tiles + cache for all zoom levels, except track view and background refresh

  if (useTiles) {
    const latMid = (baseParams.minLat + baseParams.maxLat) / 2;
    const lonMid = (baseParams.minLon + baseParams.maxLon) / 2;

    const tiles = [
      { minLat: baseParams.minLat, maxLat: latMid, minLon: baseParams.minLon, maxLon: lonMid }, // SW
      { minLat: baseParams.minLat, maxLat: latMid, minLon: lonMid, maxLon: baseParams.maxLon }, // SE
      { minLat: latMid, maxLat: baseParams.maxLat, minLon: baseParams.minLon, maxLon: lonMid }, // NW
      { minLat: latMid, maxLat: baseParams.maxLat, minLon: lonMid, maxLon: baseParams.maxLon }  // NE
    ];

    let activeSources = 0;

    // Open parallel SSE connections for each tile (or use cache)
    tiles.forEach((tile, idx) => {
      const params = { ...baseParams, ...tile };
      const cacheKey = tileCache.makeKey(zoom, tile.minLat, tile.minLon, tile.maxLat, tile.maxLon);
      const cached = tileCache.get(cacheKey);

      if (cached) {
        // Use cached data - render immediately
        console.log(`[Cache HIT] Tile ${idx} from cache`);
        cached.forEach(markerData => {
          renderCachedMarker(markerData, tracks, minTs, maxTs, savedRange, zoom);
        });
      } else {
        // Cache miss - fetch from server
        console.log(`[Cache MISS] Tile ${idx} fetching...`);
        activeSources++;
        const es = new EventSource('/stream_markers?' + new URLSearchParams(params));
        window.markerStreamSources.push(es);
        setupMarkerStream(es, tracks, minTs, maxTs, savedRange, idx, cacheKey, () => {
          activeSources--;
          // Note: loadingEl is available through closure from updateMarkers()
          if (activeSources === 0 && loadingEl) {
            loadingEl.style.display = 'none';
          }
        }, zoom, loadingEl);
      }
    });

    // Use first stream as primary for backwards compatibility
    if (window.markerStreamSources.length > 0) {
      markerStreamSource = window.markerStreamSources[0];
    }

    // If all tiles were cached, hide loading immediately
    if (activeSources === 0 && loadingEl) {
      loadingEl.style.display = 'none';
    }
  } else {
    // Single stream for track view or zoomed-out view (no caching for these)
    const es = new EventSource('/stream_markers?' + new URLSearchParams(baseParams));
    markerStreamSource = es;
    window.markerStreamSources = [es];
    setupMarkerStream(es, tracks, minTs, maxTs, savedRange, 0, null, () => {
      if (loadingEl) loadingEl.style.display = 'none';
    }, zoom, loadingEl);
  }
}

// Helper function to render a cached marker
function renderCachedMarker(m, tracks, minTs, maxTs, savedRange, zoom) {
  const isLive = m.speed < 0;
  if (!isLive && m.trackID) tracks.add(m.trackID);

  if (savedRange && (m.date < savedRange[0] || m.date > savedRange[1])) return;
  if (!shouldDisplayBySpeed(m.speed)) return;
  let marker;

  if (isLive) {
    const nowSec = Date.now() / 1000;
    const icon = buildRealtimeIcon(m, zoom, nowSec);
    if (!icon) return;
    marker = L.marker([m.lat, m.lon], {
      icon: L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]})
    });
    queueMarkerForBatch(marker, m.id);
    
    // Lazy-bind tooltip and popup only on user interaction
    (function(m, marker) {
      marker.on('mouseover', function() {
        if (!this._tooltip) {
          this.bindTooltip(getTooltipContent(m), { 
            direction:'top', 
            className:'custom-tooltip', 
            offset:[0,-8], 
            interactive:true 
          });
        }
      });
      
      // Directly open chart modal on click for RT sensors
      marker.on('click', function() {
        const deviceID = m.deviceID || (m.trackID ? m.trackID.replace(/^live:/, '') : '');
        if (deviceID) {
          const fallback = {
            device: deviceID,
            name: m.deviceName || '',
            transport: m.transport || '',
            tube: m.tube || '',
            country: m.country || '',
            lat: m.lat || '',
            lon: m.lon || '',
            doseRate: m.doseRate || null,
            date: m.date || null,
          };
          openLiveModal(deviceID, fallback);
        }
      });
    })(m, marker);
  } else {
    const hasSpectrum = m.hasSpectrum || false;
    if (hasSpectrum) {
      const baseRadius = getRadius(m.doseRate, zoom);
      const radius = baseRadius * 3;
      const size = radius * 3.7;
      const fillColor = getGradientColor(m.doseRate);
      const value = formatPrimaryUnit(m.doseRate);
      const fontSize = Math.max(Math.round(size * 0.32), 11);
      const html = `
        <div class="spectrum-marker" style="background:${fillColor};border:3px solid var(--isotope-highlight);color:#000000;width:${size}px;height:${size}px;border-radius:0;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:${fontSize}px;font-weight:bold;">
          <div style="font-size:${Math.max(fontSize * 0.8, 10)}px;">üìä</div>
          <div>${value}</div>
        </div>`;
      marker = L.marker([m.lat, m.lon], {
        icon: L.divIcon({className:'', html: html, iconSize:[size, size], iconAnchor:[size/2, size/2]})
      });
      queueMarkerForBatch(marker, m.id);
      
      // Lazy-bind tooltip on hover
      (function(m, marker) {
        marker.on('mouseover', function() {
          if (!this._tooltip) {
            this.bindTooltip(getTooltipContent(m), { 
              direction:'top', 
              className:'custom-tooltip', 
              offset:[0,-8], 
              interactive:true 
            });
          }
        });
      })(m, marker);

      // Open spectrum modal on click
      marker.on('click', function() { openSpectrumModal(m.id, m); });
    } else {
      const fillColor = getGradientColor(m.doseRate);
      // Use cached style calculation for better performance
      const markerStyle = getCachedMarkerStyle(m.doseRate, zoom, m.speed);

      marker = L.circleMarker([m.lat, m.lon], markerStyle);
      queueMarkerForBatch(marker, m.id);
      
      // Lazy-bind tooltip and popup only on user interaction
      (function(m, marker) {
        marker.on('mouseover', function() {
          if (!this._tooltip) {
            this.bindTooltip(getTooltipContent(m), { 
              direction:'top', 
              className:'custom-tooltip', 
              offset:[0,-8], 
              interactive:true 
            });
          }
        });
        
        marker.on('click', function() {
          if (!this._popup) {
            this.bindPopup(getPopupContent(m));
          }
        });
      })(m, marker);
    }
  }

  marker.doseRate = m.doseRate;
  marker.date = m.date;
  marker.isRealtime = isLive;
  marker.hasSpectrum = m.hasSpectrum || false;
  marker.markerId = m.id;
  circleMarkers[m.id || m.trackID] = marker;
}

// Helper function to setup marker stream event handlers
function setupMarkerStream(es, tracks, minTs, maxTs, savedRange, tileIndex, cacheKey, onDone, zoom, loadingEl) {
  // Debug: Verify loadingEl is defined
  if (!loadingEl) {
    console.warn('WARNING: loadingEl is undefined in setupMarkerStream! This will cause errors.');
  }

  // Track bounds while loading markers
  let markerBounds = { minLat: 90, minLon: 180, maxLat: -90, maxLon: -180, hasData: false };

  // Collect markers for caching
  const tileMarkers = cacheKey ? [] : null;

  es.onmessage = e => {
    let m; try { m = JSON.parse(e.data); } catch { return; }
    const isLive = m.speed < 0; // negative speed denotes realtime marker
    if (!isLive && m.trackID) tracks.add(m.trackID);
    minTs = Math.min(minTs, m.date);
    maxTs = Math.max(maxTs, m.date);

    // Update bounds as markers load
    if (!isLive) {
      markerBounds.minLat = Math.min(markerBounds.minLat, m.lat);
      markerBounds.maxLat = Math.max(markerBounds.maxLat, m.lat);
      markerBounds.minLon = Math.min(markerBounds.minLon, m.lon);
      markerBounds.maxLon = Math.max(markerBounds.maxLon, m.lon);
      markerBounds.hasData = true;
    }
    if (savedRange && (m.date < savedRange[0] || m.date > savedRange[1])) return;
    if (!shouldDisplayBySpeed(m.speed)) return;

    let marker;
    if (isLive) { // realtime marker with value inside the circle
      const nowSec = Date.now() / 1000;
      const icon = buildRealtimeIcon(m, zoom, nowSec);
      if (!icon) return; // device is older than 24 hours
      marker = L.marker([m.lat, m.lon], {
        icon: L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]})
      });
      queueMarkerForBatch(marker, m.id);
      
      // Lazy-bind tooltip and popup only on user interaction
      (function(m, marker) {
        marker.on('mouseover', function() {
          if (!this._tooltip) {
            this.bindTooltip(getTooltipContent(m), { 
              direction:'top', 
              className:'custom-tooltip', 
              offset:[0,-8], 
              interactive:true 
            });
          }
        });
        
        // Directly open chart modal on click for RT sensors
        marker.on('click', function() {
          const deviceID = m.deviceID || (m.trackID ? m.trackID.replace(/^live:/, '') : '');
          if (deviceID) {
            const fallback = {
              device: deviceID,
              name: m.deviceName || '',
              transport: m.transport || '',
              tube: m.tube || '',
              country: m.country || '',
              lat: m.lat || '',
              lon: m.lon || '',
              doseRate: m.doseRate || null,
              date: m.date || null,
            };
            openLiveModal(deviceID, fallback);
          }
        });
      })(m, marker);
    } else {
      // Add special styling for markers with spectrum data
      const hasSpectrum = m.hasSpectrum || false;

      if (hasSpectrum) {
        // Spectrum markers: use divIcon with same size as realtime markers
        const baseRadius = getRadius(m.doseRate, zoom);
        const radius = baseRadius * 3;  // Same as realtime markers
        const size = radius * 3.7;
        const fillColor = getGradientColor(m.doseRate);
        const value = formatPrimaryUnit(m.doseRate);
        const fontSize = Math.max(Math.round(size * 0.32), 11);

        const html = `
          <div class="spectrum-marker" style="background:${fillColor};border:3px solid var(--isotope-highlight);color:#000000;width:${size}px;height:${size}px;border-radius:0;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:${fontSize}px;font-weight:bold;">
            <div style="font-size:${Math.max(fontSize * 0.8, 10)}px;">üìä</div>
            <div>${value}</div>
          </div>`;

        marker = L.marker([m.lat, m.lon], {
          icon: L.divIcon({className:'', html: html, iconSize:[size, size], iconAnchor:[size/2, size/2]})
        });
        queueMarkerForBatch(marker, m.id);
        
        // Lazy-bind tooltip on hover
        (function(m, marker) {
          marker.on('mouseover', function() {
            if (!this._tooltip) {
              this.bindTooltip(getTooltipContent(m), { 
                direction:'top', 
                className:'custom-tooltip', 
                offset:[0,-8], 
                interactive:true 
              });
            }
          });
        })(m, marker);

        // Open spectrum modal on click
        marker.on('click', function() {
          openSpectrumModal(m.id, m);
        });
      } else {
        // Regular markers: use circleMarker
        // Use cached style calculation for better performance
        const markerStyle = getCachedMarkerStyle(m.doseRate, zoom, m.speed);

        marker = L.circleMarker([m.lat, m.lon], markerStyle);
        queueMarkerForBatch(marker, m.id);
        
        // Lazy-bind tooltip and popup only on user interaction
        (function(m, marker) {
          marker.on('mouseover', function() {
            if (!this._tooltip) {
              this.bindTooltip(getTooltipContent(m), { 
                direction:'top', 
                className:'custom-tooltip', 
                offset:[0,-8], 
                interactive:true 
              });
            }
          });
          
          marker.on('click', function() {
            if (!this._popup) {
              this.bindPopup(getPopupContent(m));
            }
          });
        })(m, marker);
      }
    }

    // Store dose rate and timestamp on marker for later size updates
    marker.doseRate  = m.doseRate;
    marker.date      = m.date;
    marker.isRealtime = isLive;
    marker.hasSpectrum = m.hasSpectrum || false;
    marker.markerId = m.id;  // Store marker ID for spectrum API calls
    circleMarkers[m.id || m.trackID] = marker;

    // Collect marker data for caching
    if (tileMarkers) {
      tileMarkers.push(m);
    }
  };

  es.addEventListener('done', () => {
    flushMarkerBatch(true);  // Flush any remaining markers
    
    // Store tile data in cache
    if (cacheKey && tileMarkers) {
      tileCache.set(cacheKey, tileMarkers);
      console.log(`[Cache STORE] Tile ${tileIndex}: ${tileMarkers.length} markers cached`);
    }

    if (onDone) onDone();
    const dateSpanMonths = (isFinite(minTs) && isFinite(maxTs))
                            ? monthsApart(minTs, maxTs) : 0;
    const needSlider = !isTrackView && tracks.size > 1 && dateSpanMonths > 1;
    if (window.__setDateSliderVisibility){
      window.__setDateSliderVisibility(needSlider);
    }
    if (needSlider && window.__initSliderOnce && isFinite(minTs) && isFinite(maxTs)){
      window.__initSliderOnce(minTs, maxTs);
      window.__initSliderOnce = null;
    }
    if (needSlider && window.__syncDateSliders && isFinite(minTs) && isFinite(maxTs)){
      window.__syncDateSliders(minTs, maxTs);
    }

    // Fit map to track bounds if in track view and no URL bounds were provided
    if (isTrackView && markerBounds.hasData) {
      const urlParams = new URLSearchParams(window.location.search);
      const hasUrlBounds = urlParams.has('minLat') && urlParams.has('minLon') &&
                          urlParams.has('maxLat') && urlParams.has('maxLon');
      if (!hasUrlBounds) {
        // Fit map to the actual data bounds with some padding
        const bounds = [[markerBounds.minLat, markerBounds.minLon],
                       [markerBounds.maxLat, markerBounds.maxLon]];
        console.log('Auto-fitting map to track bounds:', bounds);
        map.fitBounds(bounds, { padding: [50, 50] });
        adjustMarkerRadius();
      } else {
        console.log('URL bounds present, using those instead of auto-fit');
      }
    }
    if (waitForDangerFit && storedUserCenter) {
      reframeAroundUser();
    }
    try {
      if (loadingEl) {
        loadingEl.style.display='none';
      }
    } catch (err) {
      console.error('Error hiding loading element:', err);
    }
    es.close();
  });

  es.onerror = () => {
    try {
      if (loadingEl) {
        loadingEl.style.display='none';
      }
    } catch (err) {
      console.error('Error hiding loading element in onerror:', err);
    }
    es.close();
  };
}

async function fetchLiveHistory(deviceID) {
  if (!deviceID) throw new Error('device');
  if (liveHistoryCache.has(deviceID)) {
    return liveHistoryCache.get(deviceID);
  }
  const resp = await fetch('/realtime_history?device=' + encodeURIComponent(deviceID));
  if (!resp.ok) {
    throw new Error('history');
  }
  const data = await resp.json();
  liveHistoryCache.set(deviceID, data);
  return data;
}

// Spectrum data caching and visualization
const spectrumCache = new Map();
let activeSpectrumCharts = new Map();

async function fetchSpectrum(markerID) {
  if (!markerID) return null;
  if (spectrumCache.has(markerID)) {
    return spectrumCache.get(markerID);
  }
  try {
    const resp = await fetch(`/api/spectrum/${markerID}`);
    if (!resp.ok) return null;
    const data = await resp.json();
    spectrumCache.set(markerID, data);
    return data;
  } catch (err) {
    console.error('Error fetching spectrum:', err);
    return null;
  }
}

function renderSpectrumChart(markerID, spectrum) {
  const canvasId = `spectrum-chart-${markerID}`;
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;

  // Destroy existing chart if it exists
  if (activeSpectrumCharts.has(canvasId)) {
    activeSpectrumCharts.get(canvasId).destroy();
  }

  const ctx = canvas.getContext('2d');

  // Calculate energy values for each channel
  const cal = spectrum.calibration || { a: 0, b: spectrum.energyMaxKeV / spectrum.channelCount, c: 0 };
  const energies = spectrum.channels.map((_, i) => cal.a + cal.b * i + cal.c * i * i);

  const colors = chartColors();

  const chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: energies,
      datasets: [{
        label: 'Counts',
        data: spectrum.channels,
        borderColor: '#FFD700',
        backgroundColor: 'rgba(255, 215, 0, 0.1)',
        borderWidth: 1,
        pointRadius: 0,
        tension: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          type: 'linear',
          title: {
            display: true,
            text: 'Energy (keV)',
            color: colors.text
          },
          ticks: { color: colors.text },
          grid: { color: colors.grid }
        },
        y: {
          type: 'logarithmic',
          title: {
            display: true,
            text: 'Counts',
            color: colors.text
          },
          ticks: { color: colors.text },
          grid: { color: colors.grid }
        }
      },
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          callbacks: {
            title: function(context) {
              return `Energy: ${context[0].label} keV`;
            },
            label: function(context) {
              return `Counts: ${context.parsed.y}`;
            }
          }
        },
        zoom: {
          pan: {
            enabled: true,
            mode: 'xy'
          },
          zoom: {
            wheel: {
              enabled: false
            },
            drag: {
              enabled: true,
              backgroundColor: 'rgba(255, 215, 0, 0.3)',
              borderColor: '#FFD700',
              borderWidth: 2
            },
            mode: 'xy',
            onZoomComplete: function({chart}) {
              chart.update('none');
            }
          },
          limits: {
            x: {min: 'original', max: 'original'},
            y: {min: 'original', max: 'original'}
          }
        },
        resetZoom: {
          enabled: true
        }
      },
      onClick: function(evt, activeEls, chart) {
        if (evt.native.detail === 2) {
          chart.resetZoom();
        }
      },
      onHover: function(evt, activeEls, chart) {
        evt.native.target.style.cursor = activeEls.length > 0 ? 'pointer' : 'crosshair';
      }
    }
  });

  activeSpectrumCharts.set(canvasId, chart);
}

async function loadAndRenderSpectrum(markerID) {
  const spectrum = await fetchSpectrum(markerID);
  if (spectrum) {
    renderSpectrumChart(markerID, spectrum);
  }
}

function downloadSpectrum(markerID, format) {
  const url = `/api/spectrum/${markerID}/download?format=${format}`;
  const link = document.createElement('a');
  link.href = url;
  link.download = `spectrum_${markerID}.${format}`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

function chartColors() {
  const theme = document.documentElement.dataset.theme;
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const dark = theme === 'dark' || (!theme && prefersDark);
  if (dark) {
    return { grid: 'rgba(255,255,255,0.3)', line: '#64b5f6', text: '#ffffff', background: 'rgba(255,255,255,0.1)' };
  }
  return { grid: 'rgba(0,0,0,0.2)', line: '#1e88e5', text: '#333333', background: 'rgba(0,0,0,0.05)' };
}

function radiationLineColor(valueMicroRoentgen) {
  return getGradientColor(valueMicroRoentgen / 100);
}

function niceNumber(range, round) {
  if (!isFinite(range) || range === 0) return 0;
  const exponent = Math.floor(Math.log10(Math.abs(range)));
  const fraction = range / Math.pow(10, exponent);
  let niceFraction;
  if (round) {
    if (fraction < 1.5) niceFraction = 1;
    else if (fraction < 3) niceFraction = 2;
    else if (fraction < 7) niceFraction = 5;
    else niceFraction = 10;
  } else {
    if (fraction <= 1) niceFraction = 1;
    else if (fraction <= 2) niceFraction = 2;
    else if (fraction <= 5) niceFraction = 5;
    else niceFraction = 10;
  }
  return niceFraction * Math.pow(10, exponent);
}

function niceTicks(min, max, count) {
  if (!isFinite(min) || !isFinite(max) || count <= 0) return [];
  if (min === max) return [min];
  const range = niceNumber(max - min, false);
  if (range === 0) return [];
  const spacing = niceNumber(range / (count - 1), true);
  if (!isFinite(spacing) || spacing === 0) return [];
  const niceMin = Math.floor(min / spacing) * spacing;
  const niceMax = Math.ceil(max / spacing) * spacing;
  const ticks = [];
  for (let v = niceMin; v <= niceMax + spacing / 2; v += spacing) {
    ticks.push(v);
  }
  return ticks;
}

const TIME_TICK_STEPS = [
  60,
  120,
  300,
  600,
  900,
  1800,
  3600,
  7200,
  14400,
  21600,
  43200,
  86400,
  172800,
  604800,
  1209600,
  2592000,
  7776000,
  15552000,
  31536000,
];

function selectTimeStep(spanSeconds, bucketSeconds) {
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return bucketSeconds || 60;
  }
  let minStep = spanSeconds / 6;
  if (bucketSeconds && bucketSeconds > minStep) {
    minStep = bucketSeconds;
  } else if (bucketSeconds) {
    minStep = Math.max(bucketSeconds, minStep / 2);
  }
  for (let i = 0; i < TIME_TICK_STEPS.length; i++) {
    if (TIME_TICK_STEPS[i] >= minStep) {
      return TIME_TICK_STEPS[i];
    }
  }
  return Math.max(bucketSeconds || TIME_TICK_STEPS[TIME_TICK_STEPS.length - 1], Math.round(minStep));
}

function buildTimeTicks(start, end, bucketSeconds) {
  if (!isFinite(start) || !isFinite(end) || end <= start) return [];
  const span = end - start;
  const step = selectTimeStep(span, bucketSeconds);
  if (!isFinite(step) || step <= 0) return [];
  const ticks = [];
  const first = Math.ceil(start / step) * step;
  for (let ts = first; ts <= end; ts += step) {
    ticks.push(ts);
  }
  return ticks;
}

function secondsForUnit(unit) {
  switch (unit) {
    case 'hour':
      return 3600;
    case 'day':
      return 86400;
    default:
      return 0;
  }
}

// buildSegmentTicks divides the range into evenly spaced segments without relying
// on heuristics so the canvas grid can honour strict hour/day/month splits.
function buildSegmentTicks(start, end, segments, unit) {
  if (!isFinite(start) || !isFinite(end) || end <= start) return [];
  if (!segments || segments <= 0) return [];
  if (unit === 'month') {
    const ticks = [];
    let cursor = new Date(start * 1000);
    cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth(), 1, 0, 0, 0, 0));
    for (let i = 1; i < segments; i++) {
      cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth() + 1, 1, 0, 0, 0, 0));
      const ts = Math.floor(cursor.getTime() / 1000);
      if (ts <= start || ts >= end) {
        continue;
      }
      ticks.push(ts);
    }
    return ticks;
  }
  const step = secondsForUnit(unit);
  if (!step) return [];
  const ticks = [];
  for (let i = 1; i < segments; i++) {
    const ts = start + step * i;
    if (ts <= start || ts >= end) continue;
    ticks.push(ts);
  }
  return ticks;
}

function formatTimeTickLabel(ts, spanSeconds, lang) {
  if (!isFinite(ts)) return '';
  const date = new Date(ts * 1000);
  if (!isFinite(spanSeconds) || spanSeconds <= 0) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 48 * 3600) {
    return date.toLocaleString(lang, { hour: '2-digit', minute: '2-digit' });
  }
  if (spanSeconds <= 90 * 86400) {
    return date.toLocaleString(lang, { month: 'short', day: 'numeric', hour: '2-digit' });
  }
  if (spanSeconds <= 400 * 86400) {
    return date.toLocaleDateString(lang, { month: 'short', day: 'numeric' });
  }
  if (spanSeconds <= 5 * 365 * 86400) {
    return date.toLocaleDateString(lang, { year: 'numeric', month: 'short' });
  }
  return date.toLocaleDateString(lang, { year: 'numeric' });
}

function formatAveragingWindow(seconds) {
  if (!seconds || !isFinite(seconds)) return '';
  const abs = Math.abs(seconds);
  const units = [
    { limit: 3600, key: 'duration_minutes', divisor: 60 },
    { limit: 48 * 3600, key: 'duration_hours', divisor: 3600 },
    { limit: 14 * 86400, key: 'duration_days', divisor: 86400 },
    { limit: 90 * 86400, key: 'duration_weeks', divisor: 604800 },
    { limit: Infinity, key: 'duration_months', divisor: 2592000 },
  ];
  let chosen = units[units.length - 1];
  for (let i = 0; i < units.length; i++) {
    if (abs < units[i].limit) {
      chosen = units[i];
      break;
    }
  }
  const template = translate(chosen.key);
  if (!template) return '';
  const count = Math.max(1, Math.round(abs / chosen.divisor));
  return template.replace('[[count]]', count);
}

function describeRangeLabel(range) {
  if (!range || typeof range.start !== 'number' || typeof range.end !== 'number') return '';
  if (range.end <= range.start) return '';
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const span = range.end - range.start;
  let startOpts;
  let endOpts;
  if (span <= 48 * 3600) {
    startOpts = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    endOpts = startOpts;
  } else if (span <= 120 * 86400) {
    startOpts = { month: 'short', day: 'numeric' };
    endOpts = { month: 'short', day: 'numeric' };
  } else if (span <= 720 * 86400) {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  } else {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  }
  const startText = new Date(range.start * 1000).toLocaleString(lang, startOpts);
  const endText = new Date(range.end * 1000).toLocaleString(lang, endOpts);
  if (!startText || !endText) return '';
  return startText + ' ‚Üí ' + endText;
}

function drawLiveChart(canvas, radiationPoints, extrasByKey, options) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (width === 0 || height === 0) return;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, width, height);

  const colors = chartColors();
  canvas.style.background = colors.background;

  const fontTokens = resolveFontTokens(); // Use CSS-driven sizes so canvas labels match the rest of the UI.
  const fonts = {
    axisY: fontTokens.sm + ' ' + fontTokens.family,
    axisX: fontTokens.xs + ' ' + fontTokens.family,
    extras: fontTokens.sm + ' ' + fontTokens.family,
    legend: fontTokens.base + ' ' + fontTokens.family,
  };

  const extras = {};
  if (extrasByKey && typeof extrasByKey === 'object') {
    Object.keys(extrasByKey).forEach(function(key) {
      const series = extrasByKey[key];
      if (Array.isArray(series) && series.length) {
        // Handle temperature conversion based on preference
        if (key === 'temperature_c') {
          if (preferredTempUnit === 'F') {
            // Convert Celsius to Fahrenheit
            extras['temperature_f'] = series.map(p => ({
              timestamp: p.timestamp,
              value: (p.value * 9/5) + 32
            }));
          } else {
            extras[key] = series;
          }
        } else if (key === 'temperature_f') {
          if (preferredTempUnit === 'C') {
            // Convert Fahrenheit to Celsius
            extras['temperature_c'] = series.map(p => ({
              timestamp: p.timestamp,
              value: (p.value - 32) * 5/9
            }));
          } else {
            extras[key] = series;
          }
        } else {
          extras[key] = series;
        }
      }
    });
  }
  const extraKeys = sortExtraKeys(Object.keys(extras));
  const hasRadiation = Array.isArray(radiationPoints) && radiationPoints.length > 0;
  if (!hasRadiation && extraKeys.length === 0) {
    return;
  }

  const baseSeries = hasRadiation ? radiationPoints : extras[extraKeys[0]];
  if (!baseSeries || !baseSeries.length) {
    return;
  }

  const opts = options || {};
  let minX = baseSeries[0].timestamp;
  let maxX = baseSeries[baseSeries.length - 1].timestamp || (minX + 1);
  if (typeof opts.start === 'number' && typeof opts.end === 'number' && opts.end > opts.start) {
    minX = opts.start;
    maxX = opts.end;
  }
  if (!(maxX > minX)) {
    maxX = minX + 1;
  }
  const bucketSeconds = typeof opts.bucketSeconds === 'number' ? opts.bucketSeconds : 0;

  let minY;
  let maxY;
  
  // Recalculate range based on zoom
  if (canvas._zoomRanges) {
    minX = canvas._zoomRanges.minX;
    maxX = canvas._zoomRanges.maxX;
    
    // Auto-scale Y based on visible data
    let visibleMinY = Infinity;
    let visibleMaxY = -Infinity;
    let hasVisible = false;

    const findVisible = function(series) {
      if (!Array.isArray(series)) return;
      series.forEach(point => {
        if (point.timestamp >= minX && point.timestamp <= maxX) {
          if (point.value < visibleMinY) visibleMinY = point.value;
          if (point.value > visibleMaxY) visibleMaxY = point.value;
          hasVisible = true;
        }
      });
    };

    if (hasRadiation) findVisible(radiationPoints);
    extraKeys.forEach(key => findVisible(extras[key]));

    if (hasVisible) {
      minY = 0;
      maxY = visibleMaxY;
    } else {
      // Fallback if no points visible in this X range
      minY = 0;
      maxY = canvas._zoomRanges.maxY;
    }
  } else {
    // Original scaling logic: Start at 0, end at max level
    minY = 0;
    let foundMax = -Infinity;
    if (hasRadiation) {
      radiationPoints.forEach(function(point) {
        if (point.value > foundMax) foundMax = point.value;
      });
    } else if (extraKeys.length > 0) {
      const key = extraKeys[0];
      extras[key].forEach(function(point) {
        if (point.value > foundMax) foundMax = point.value;
      });
    }
    maxY = (foundMax === -Infinity) ? 1.0 : foundMax;
  }

  if (minY === maxY) {
    const delta = minY === 0 ? 0.5 : Math.abs(minY) * 0.2;
    minY -= delta;
    maxY += delta;
  }

  const extraRanges = {};
  extraKeys.forEach(function(key) {
    const series = extras[key];
    let minVal, maxVal;

    if (canvas._zoomRanges) {
       // For extra scales, we also want to auto-scale them if zoomed?
       // Let's do it for consistency.
       let vMin = Infinity;
       let vMax = -Infinity;
       let vHas = false;
       series.forEach(p => {
         if (p.timestamp >= minX && p.timestamp <= maxX) {
           if (p.value < vMin) vMin = p.value;
           if (p.value > vMax) vMax = p.value;
           vHas = true;
         }
       });
       if (vHas) {
         minVal = vMin;
         maxVal = vMax;
       } else {
         minVal = series[0].value;
         maxVal = series[0].value;
       }
    } else {
      minVal = series[0].value;
      maxVal = series[0].value;
      series.forEach(function(point) {
        if (point.value < minVal) minVal = point.value;
        if (point.value > maxVal) maxVal = point.value;
      });
    }

    // Special handling for temperature scales
    if (key === 'temperature_c' || key === 'temperature_f') {
      const zeroPoint = key === 'temperature_c' ? 0 : 32; // 0¬∞C or 32¬∞F
      if (minVal > zeroPoint) {
        // If all temperatures are above zero, start scale at ~0
        minVal = zeroPoint;
      }
      // If minVal is below zero, keep the actual minimum (which is already set)
    }

    if (minVal === maxVal) {
      const delta = minVal === 0 ? 0.5 : Math.abs(minVal) * 0.2;
      minVal -= delta;
      maxVal += delta;
    }
    extraRanges[key] = { min: minVal, max: maxVal };
  });

  const extraColumnWidth = 72;
  const rightPad = extraKeys.length ? extraColumnWidth * extraKeys.length + 20 : 20;
  const leftPad = hasRadiation ? 70 : 50;
  const topPad = 64;
  const bottomPad = 44;

  const plotLeft = leftPad;
  const plotRight = width - rightPad;
  const plotTop = topPad;
  const plotBottom = height - bottomPad;
  const plotW = Math.max(plotRight - plotLeft, 10);
  const plotH = Math.max(plotBottom - plotTop, 10);

  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const spanSeconds = maxX - minX;

  const rangeX = (maxX - minX) || 1;
  const rangeY = hasRadiation ? ((maxY - minY) || 1) : 1;

  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(plotLeft, plotTop);
  ctx.lineTo(plotLeft, plotBottom);
  ctx.lineTo(plotRight, plotBottom);
  if (extraKeys.length) {
    ctx.moveTo(plotRight, plotTop);
    ctx.lineTo(plotRight, plotBottom);
  }
  ctx.stroke();

  const ticksY = niceTicks(minY, maxY, 5);
  // Calculate required precision for Y axis labels based on tick spacing to ensure they are unique
  let precisionY = null;
  if (ticksY.length > 1) {
    const spacingY = Math.abs(ticksY[1] - ticksY[0]);
    const displaySpacingY = currentUnit === 'uSv' ? spacingY / 100 : spacingY;
    if (displaySpacingY > 0 && displaySpacingY < 1) {
       precisionY = Math.max(0, Math.ceil(-Math.log10(displaySpacingY)));
    }
  }

  ctx.font = fonts.axisY;
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ticksY.forEach(function(value) {
    if (!isFinite(value)) return;
    const y = plotBottom - ((value - minY) / rangeY) * plotH;
    ctx.strokeStyle = colorWithAlpha(colors.grid, 0.5);
    ctx.beginPath();
    ctx.moveTo(plotLeft, y);
    ctx.lineTo(plotRight, y);
    ctx.stroke();
    const label = formatChartValue(value, precisionY);
    ctx.fillStyle = colors.text;
    ctx.fillText(label, plotLeft - 8, y);
  });

  const tickUnit = opts.tickUnit || null;
  const tickSegments = opts.tickSegments || 0;
  const forcedTicks = (tickUnit && tickSegments > 0) ? buildSegmentTicks(minX, maxX, tickSegments, tickUnit) : null;
  const ticksX = forcedTicks && forcedTicks.length ? forcedTicks : buildTimeTicks(minX, maxX, bucketSeconds);
  const approxStep = (tickUnit && tickSegments > 0)
    ? (tickUnit === 'month' ? (maxX - minX) / tickSegments : secondsForUnit(tickUnit))
    : (bucketSeconds || 0);
  const axisLabelY = height - 12;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = fonts.axisX;
  ctx.strokeStyle = colorWithAlpha(colors.grid, 0.35);

  let lastLabelX = -Infinity;
  const minLabelGap = 12; // Minimum pixel gap between X-axis labels
  
  // Create a combined list of candidates including endpoints
  let candidatesX = ticksX.slice();
  if (!candidatesX.includes(minX)) candidatesX.push(minX);
  if (!candidatesX.includes(maxX)) candidatesX.push(maxX);
  candidatesX.sort(function(a, b) { return a - b; });

  candidatesX.forEach(function(ts) {
    if (!isFinite(ts)) return;
    const x = plotLeft + ((ts - minX) / rangeX) * plotW;
    
    // Grid lines only for actual ticks (to keep it clean)
    if (ticksX.includes(ts)) {
      ctx.beginPath();
      ctx.moveTo(x, plotTop);
      ctx.lineTo(x, plotBottom);
      ctx.stroke();
    }

    const label = formatTimeTickLabel(ts, spanSeconds, lang);
    if (!label) return;

    const labelWidth = ctx.measureText(label).width;
    
    // Decide alignment: flush for endpoints if they are at the very edges
    let align = 'center';
    if (ts === minX) align = 'left';
    else if (ts === maxX) align = 'right';
    
    let labelStart, labelEnd;
    if (align === 'center') {
      labelStart = x - labelWidth / 2;
      labelEnd = x + labelWidth / 2;
    } else if (align === 'left') {
      labelStart = x;
      labelEnd = x + labelWidth;
    } else {
      labelStart = x - labelWidth;
      labelEnd = x;
    }

    // Only draw the label if it doesn't overlap with the previous one
    if (labelStart > lastLabelX + minLabelGap) {
      ctx.textAlign = align;
      ctx.fillStyle = colors.text;
      ctx.fillText(label, x, axisLabelY);
      lastLabelX = labelEnd;
    }
  });

  // Draw data lines with clipping to prevent bleeding outside the plot area
  ctx.save();
  ctx.beginPath();
  ctx.rect(plotLeft, plotTop, plotW, plotH);
  ctx.clip();

  // Helpers for coordinate mapping
  const getX = (ts) => plotLeft + ((ts - minX) / rangeX) * plotW;
  const getY = (val) => plotBottom - ((val - minY) / rangeY) * plotH;

  // Smoothing tension (0.15 is safe and prevents looping/overshooting)
  const tension = 0.15;

  if (hasRadiation && radiationPoints.length > 1) {
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    const pts = radiationPoints.map(p => ({
      x: getX(p.timestamp),
      y: getY(p.value),
      val: p.value,
      ts: p.timestamp
    }));

    // Build paths for fill and stroke
    const fillPath = new Path2D();
    const linePath = new Path2D();
    
    fillPath.moveTo(pts[0].x, pts[0].y);
    linePath.moveTo(pts[0].x, pts[0].y);

    for (let i = 0; i < pts.length - 1; i++) {
        const p1 = pts[i];
        const p2 = pts[i + 1];
        const p0 = pts[i - 1] || p1;
        const p3 = pts[i + 2] || p2;
        
        // Prevent x-overshoot by centering the tension on the local interval
        const dx = p2.x - p1.x;
        const cp1x = p1.x + dx * tension * 3; 
        const cp1y = p1.y + (p2.y - p0.y) * tension;
        const cp2x = p2.x - dx * tension * 3;
        const cp2y = p2.y - (p3.y - p1.y) * tension;
        
        fillPath.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
        linePath.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
    }

    // Finish fill path
    fillPath.lineTo(pts[pts.length - 1].x, plotBottom);
    fillPath.lineTo(pts[0].x, plotBottom);
    fillPath.closePath();

    // Create a global gradient for the entire line path
    const mainGradient = ctx.createLinearGradient(plotLeft, 0, plotRight, 0);
    // Add color stops for each point to ensure faithful color representation
    pts.forEach(p => {
        const pos = (p.x - plotLeft) / plotW;
        if (pos >= 0 && pos <= 1) {
            mainGradient.addColorStop(pos, radiationLineColor(p.val));
        }
    });

    // Draw the fill
    const fillGradient = ctx.createLinearGradient(0, plotTop, 0, plotBottom);
    const middleVal = pts[Math.floor(pts.length/2)].val;
    const baseColor = radiationLineColor(middleVal);
    fillGradient.addColorStop(0, colorWithAlpha(baseColor, 0.2));
    fillGradient.addColorStop(1, colorWithAlpha(baseColor, 0.01));
    ctx.fillStyle = fillGradient;
    ctx.fill(fillPath);

    // Draw the line in ONE single stroke for perfect smoothing
    ctx.strokeStyle = mainGradient;
    ctx.stroke(linePath);
  } else if (hasRadiation && radiationPoints.length === 1) {
    const lone = radiationPoints[0];
    const x = getX(lone.timestamp);
    const y = getY(lone.value);
    if (lone.timestamp >= minX && lone.timestamp <= maxX) {
      ctx.fillStyle = radiationLineColor(lone.value);
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  extraKeys.forEach(function(key) {
    const series = extras[key];
    const range = extraRanges[key];
    const denom = (range.max - range.min) || 1;
    const color = colorForExtraKey(key);
    
    if (!series || series.length < 2) return;

    const getExtraY = (val) => plotBottom - ((val - range.min) / denom) * plotH;
    const pts = series.map(p => ({
      x: getX(p.timestamp),
      y: getExtraY(p.value),
      ts: p.timestamp
    }));

    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 3]);
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);

    for (let i = 0; i < pts.length - 1; i++) {
      const p1 = pts[i];
      const p2 = pts[i + 1];
      const p0 = pts[i - 1] || p1;
      const p3 = pts[i + 2] || p2;

      const dx = p2.x - p1.x;
      const cp1x = p1.x + dx * tension * 3;
      const cp1y = p1.y + (p2.y - p0.y) * tension;
      const cp2x = p2.x - dx * tension * 3;
      const cp2y = p2.y - (p3.y - p1.y) * tension;

      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
  });

  ctx.restore();

  // Draw extra series labels (outside the clipping mask)
  extraKeys.forEach(function(key, idx) {
    const range = extraRanges[key];
    const color = colorForExtraKey(key);
    const xBase = plotRight + 8 + idx * extraColumnWidth;
    const suffix = extraUnitSuffix(key);
    const maxLabel = formatExtraAxisValue(key, range.max);
    const minLabel = formatExtraAxisValue(key, range.min);
    ctx.font = fonts.extras;
    ctx.fillStyle = color;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    if (maxLabel) {
      ctx.fillText(maxLabel + (suffix ? ' ' + suffix : ''), xBase, plotTop + 12);
    }
    if (minLabel) {
      ctx.fillText(minLabel + (suffix ? ' ' + suffix : ''), xBase, plotBottom - 4);
    }
    
    // Draw 0-degree reference line for temperature (only if temperature goes below zero)
    if (key === 'temperature_c' || key === 'temperature_f') {
      const zeroPoint = key === 'temperature_c' ? 0 : 32;
      if (range.min < zeroPoint && zeroPoint <= range.max) {
        const denom = (range.max - range.min) || 1;
        const zeroY = plotBottom - ((zeroPoint - range.min) / denom) * plotH;
        
        // Draw dashed line across the plot
        ctx.save();
        ctx.strokeStyle = colorWithAlpha(color, 0.6);
        ctx.lineWidth = 1.5;
        ctx.setLineDash([8, 4]);
        ctx.beginPath();
        ctx.moveTo(plotLeft, zeroY);
        ctx.lineTo(plotRight, zeroY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
        
        // Draw label at 0¬∞
        const zeroLabel = key === 'temperature_c' ? '0¬∞C' : '32¬∞F';
        ctx.fillStyle = color;
        ctx.font = fonts.extras;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(zeroLabel, xBase, zeroY);
      }
    }
  });

  // Zoom and Tooltip logic
  let baseImage = null;
  setTimeout(() => {
    if (ctx) baseImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
  }, 0);

  let zoomStart = null;
  let isZooming = false;

  let tooltip = document.getElementById('liveChartTooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'liveChartTooltip';
    tooltip.style.cssText = `
      position: absolute;
      display: none;
      background: var(--modal-bg);
      color: var(--modal-text);
      border: 1px solid var(--legend-border);
      border-radius: 4px;
      padding: 6px 10px;
      font-size: var(--font-size-sm);
      pointer-events: none;
      z-index: 10000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    document.body.appendChild(tooltip);
  }

  const onMouseMove = function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (isZooming && zoomStart && baseImage) {
      tooltip.style.display = 'none';
      ctx.putImageData(baseImage, 0, 0);
      ctx.strokeStyle = '#FFD700';
      ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
      ctx.lineWidth = 2;
      ctx.fillRect(zoomStart.x, zoomStart.y, x - zoomStart.x, y - zoomStart.y);
      ctx.strokeRect(zoomStart.x, zoomStart.y, x - zoomStart.x, y - zoomStart.y);
      e.preventDefault();
      return;
    }

    if (x < plotLeft || x > plotRight || y < plotTop || y > plotBottom) {
      tooltip.style.display = 'none';
      return;
    }

    const dataX = minX + ((x - plotLeft) / plotW) * rangeX;
    let closest = null;
    let minDist = Infinity;
    
    const findClosest = (series) => {
      if (!Array.isArray(series)) return;
      series.forEach(p => {
        const dist = Math.abs(p.timestamp - dataX);
        if (dist < minDist) {
          minDist = dist;
          closest = p;
        }
      });
    };

    findClosest(radiationPoints);
    extraKeys.forEach(k => findClosest(extras[k]));

    if (closest && minDist < rangeX * 0.05) { 
      const date = new Date(closest.timestamp * 1000);
      const timeStr = date.toLocaleString(lang, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      const valStr = formatChartValue(closest.value, precisionY);
      const unit = hasRadiation && radiationPoints.includes(closest) ? getPrimaryUnitLabel() : '';
      
      tooltip.innerHTML = `<strong>${valStr} ${unit}</strong><br>${timeStr}`;
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 10) + 'px';
      tooltip.style.top = (e.clientY + 10) + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  };

  const onZoomStart = function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (x >= plotLeft && x <= plotRight && y >= plotTop && y <= plotBottom) {
      isZooming = true;
      zoomStart = { x, y };
      e.preventDefault();
    }
  };

  const onZoomEnd = function(e) {
    if (!isZooming || !zoomStart) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const x1 = Math.min(zoomStart.x, x);
    const x2 = Math.max(zoomStart.x, x);
    const y1 = Math.min(zoomStart.y, y);
    const y2 = Math.max(zoomStart.y, y);

    if (Math.abs(x2 - x1) > 10 && Math.abs(y2 - y1) > 10) {
      const newMinX = minX + ((x1 - plotLeft) / plotW) * rangeX;
      const newMaxX = minX + ((x2 - plotLeft) / plotW) * rangeX;
      const newMaxY = maxY - ((y1 - plotTop) / plotH) * rangeY;
      const newMinY = maxY - ((y2 - plotTop) / plotH) * rangeY;

      canvas._zoomRanges = {
        minX: newMinX,
        maxX: newMaxX,
        minY: newMinY,
        maxY: newMaxY
      };
      drawLiveChart(canvas, radiationPoints, extrasByKey, options);
    }
    isZooming = false;
    zoomStart = null;
    e.preventDefault();
  };

  const onReset = function(e) {
    if (e.detail === 2) {
      canvas._zoomRanges = null;
      drawLiveChart(canvas, radiationPoints, extrasByKey, options);
      e.preventDefault();
    }
  };

  const onMouseOut = function() {
    tooltip.style.display = 'none';
    isZooming = false;
    zoomStart = null;
  };

  if (canvas._onMove) canvas.removeEventListener('mousemove', canvas._onMove);
  if (canvas._onStart) canvas.removeEventListener('mousedown', canvas._onStart);
  if (canvas._onEnd) canvas.removeEventListener('mouseup', canvas._onEnd);
  if (canvas._onReset) canvas.removeEventListener('click', canvas._onReset);
  if (canvas._onOut) canvas.removeEventListener('mouseout', canvas._onOut);

  canvas._onMove = onMouseMove;
  canvas._onStart = onZoomStart;
  canvas._onEnd = onZoomEnd;
  canvas._onReset = onReset;
  canvas._onOut = onMouseOut;

  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mousedown', onZoomStart);
  canvas.addEventListener('mouseup', onZoomEnd);
  canvas.addEventListener('click', onReset);
  canvas.addEventListener('mouseout', onMouseOut);

  ctx.font = fonts.legend;
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'left';
  const legendY = topPad - 20;
  let legendX = plotLeft;
  const legendEntries = [];
  if (hasRadiation) {
    // The legend reuses a gradient so the key matches the multi-hued line.
    const legendGradient = ctx.createLinearGradient(legendX, legendY, legendX + 18, legendY);
    legendGradient.addColorStop(0, radiationLineColor(minY));
    legendGradient.addColorStop(1, radiationLineColor(maxY));
    legendEntries.push({ label: translate('radiation_dose') + ' (' + getPrimaryUnitLabel() + ')', color: legendGradient, solid: true });
  }
  extraKeys.forEach(function(key) {
    const suffix = extraUnitSuffix(key);
    const label = labelForExtraKey(key) + (suffix ? ' (' + suffix + ')' : '');
    legendEntries.push({ label: label, color: colorForExtraKey(key), solid: false });
  });
  legendEntries.forEach(function(entry) {
    ctx.strokeStyle = entry.color;
    ctx.lineWidth = entry.solid ? 3 : 1.5;
    ctx.setLineDash(entry.solid ? [] : [5, 3]);
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 18, legendY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = colors.text;
    ctx.fillText(entry.label, legendX + 24, legendY + 4);
    legendX += ctx.measureText(entry.label).width + 64;
  });
}


function describeRangeLabel(range) {
  if (!range || typeof range.start !== 'number' || typeof range.end !== 'number') return '';
  if (range.end <= range.start) return '';
  const lang = (typeof currentLang !== 'undefined' && currentLang) ? currentLang : 'en';
  const span = range.end - range.start;
  let startOpts;
  let endOpts;
  if (span <= 48 * 3600) {
    startOpts = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    endOpts = startOpts;
  } else if (span <= 120 * 86400) {
    startOpts = { month: 'short', day: 'numeric' };
    endOpts = { month: 'short', day: 'numeric' };
  } else if (span <= 720 * 86400) {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  } else {
    startOpts = { year: 'numeric', month: 'short' };
    endOpts = { year: 'numeric', month: 'short' };
  }
  const startText = new Date(range.start * 1000).toLocaleString(lang, startOpts);
  const endText = new Date(range.end * 1000).toLocaleString(lang, endOpts);
  if (!startText || !endText) return '';
  return startText + ' ‚Üí ' + endText;
}

function updateChartHeading(key, ranges) {
  const element = document.getElementById('liveChartTitle');
  if (!element) return;
  const base = translate('live_chart_' + key);
  const range = ranges && ranges[key];
  const desc = describeRangeLabel(range);
  element.textContent = desc ? base + ' ¬∑ ' + desc : base;
}

function updateChartWindowLabel(rangeKey, ranges) {
  const el = document.getElementById('liveChartWindow');
  if (!el) return;
  const range = ranges && ranges[rangeKey];
  if (!range || !range.bucketSeconds) {
    el.textContent = '';
    return;
  }
  const windowText = formatAveragingWindow(range.bucketSeconds);
  if (!windowText) {
    el.textContent = '';
    return;
  }
  const template = translate('live_chart_averaged');
  el.textContent = template ? template.replace('[[window]]', windowText) : windowText;
}

function hideLiveModal() {
  const modal = document.getElementById('liveModal');
  if (modal) modal.style.display = 'none';
}

async function openLiveModal(deviceID, fallback) {
  const modal = document.getElementById('liveModal');
  if (!modal) return;
  modal.style.display = 'flex';

  const titleEl = document.getElementById('liveModalTitle');
  const descEl = document.getElementById('liveModalDescription');
  const metaEl = document.getElementById('liveModalMeta');
  const extraEl = document.getElementById('liveModalExtra');

  const canvas = document.getElementById('liveChartCanvas');
  const empty = document.getElementById('liveChartEmpty');

  const closeBtn = document.getElementById('liveModalClose');
  if (closeBtn) closeBtn.textContent = translate('live_chart_close');

  const fallbackMarker = {
    deviceID: fallback && fallback.device ? String(fallback.device) : (fallback && fallback.id ? String(fallback.id) : ''),
    deviceName: fallback && fallback.name ? fallback.name : '',
    transport: fallback && fallback.transport ? fallback.transport : '',
    country: fallback && fallback.country ? fallback.country : '',
    tube: fallback && fallback.tube ? fallback.tube : '',
    doseRate: fallback && fallback.doseRate ? fallback.doseRate : null,
    date: fallback && fallback.date ? fallback.date : null,
  };

  if (titleEl) titleEl.textContent = fallbackMarker.deviceName || translate('live_marker_title');
  if (descEl) descEl.textContent = describeLiveSensor(fallbackMarker);
  if (metaEl) metaEl.innerHTML = buildDeviceMeta(fallbackMarker);
  if (extraEl) extraEl.innerHTML = '';
  
  // Initialize dose display area (will update with real data later)
  const doseEl = document.getElementById('liveModalDose');
  if (doseEl) {
    if (fallbackMarker.doseRate !== null && fallbackMarker.doseRate !== undefined) {
      console.log('Fallback dose rate:', fallbackMarker.doseRate);
      console.log('Current unit:', currentUnit);
      const primaryValue = formatPrimaryUnit(fallbackMarker.doseRate);
      const altValue = formatSecondaryUnit(fallbackMarker.doseRate);
      const primaryUnit = currentUnit === 'uR' ? '¬µR/h' : '¬µSv/h';
      const altUnit = currentUnit === 'uR' ? '¬µSv/h' : '¬µR/h';
      const local = approximateLocalTime(fallback && fallback.lat ? parseFloat(fallback.lat) : undefined, fallback && fallback.lon ? parseFloat(fallback.lon) : undefined);
      const lastSeen = fallbackMarker.date ? formatDateTime(fallbackMarker.date) : '';
      const doseColor = getGradientColor(fallbackMarker.doseRate);
      console.log('Primary value:', primaryValue, 'Color:', doseColor);
      
      doseEl.innerHTML = `
        <div class="live-modal-dose-value" style="color:${doseColor};">${primaryValue} <span style="font-size:0.45em;">${primaryUnit}</span></div>
        <div class="live-modal-dose-alt" style="color:${doseColor};">${altValue} ${altUnit}</div>
        ${lastSeen ? `<div class="live-modal-dose-time">${escapeHtml(lastSeen)}</div>` : ''}
      `;
    } else {
      console.log('No fallback dose rate available');
      doseEl.innerHTML = '<div class="live-modal-dose-value">--</div>';
    }
  } else {
    console.error('liveModalDose element not found!');
  }
  
  if (empty) { empty.textContent = ''; empty.style.display = 'none'; }
  if (canvas) {
    const ctx = canvas.getContext('2d');
    if (ctx) ctx.clearRect(0,0,canvas.width,canvas.height);
    canvas._zoomRanges = null; // Reset zoom on open
  }

  try {
    const data = await fetchLiveHistory(deviceID);
    
    const merged = {
      deviceID: data.deviceID || fallbackMarker.deviceID,
      deviceName: data.deviceName || fallbackMarker.deviceName,
      transport: data.transport || fallbackMarker.transport,
      tube: data.tube || fallbackMarker.tube,
      country: data.country || fallbackMarker.country,
      lat: fallback && fallback.lat ? parseFloat(fallback.lat) : undefined,
      lon: fallback && fallback.lon ? parseFloat(fallback.lon) : undefined,
      liveExtra: data.extra || null,
    };

    if (titleEl) titleEl.textContent = merged.deviceName || translate('live_marker_title');
    if (descEl) descEl.textContent = describeLiveSensor(merged);
    
    // Update dose display with latest data from history
    const doseEl = document.getElementById('liveModalDose');
    if (doseEl && data.series && data.series.day && data.series.day.length > 0) {
      // Get the most recent measurement
      const latest = data.series.day[data.series.day.length - 1];
      console.log('Latest data point:', latest);
      console.log('Latest value raw (¬µR/h):', latest.value, 'Current unit:', currentUnit);
      if (latest && typeof latest.value === 'number') {
        // Convert from ¬µR/h (server format) to ¬µSv/h (internal format)
        const valueSv = latest.value / 100;
        console.log('Converted to ¬µSv/h:', valueSv);
        const primaryValue = formatPrimaryUnit(valueSv);
        const altValue = formatSecondaryUnit(valueSv);
        const primaryUnit = currentUnit === 'uR' ? '¬µR/h' : '¬µSv/h';
        const altUnit = currentUnit === 'uR' ? '¬µSv/h' : '¬µR/h';
        const lastSeen = latest.timestamp ? formatDateTime(latest.timestamp) : '';
        const doseColor = getGradientColor(valueSv);
        console.log('From history - Primary value:', primaryValue, 'Color:', doseColor, 'Last seen:', lastSeen);
        
        // Get temperature from latest extra data
        let tempHtml = '';
        if (data.extraSeries && data.extraSeries.day && data.extraSeries.day.length > 0) {
          const latestExtra = data.extraSeries.day[data.extraSeries.day.length - 1];
          if (latestExtra && latestExtra.temp !== null && latestExtra.temp !== undefined) {
            const tempC = latestExtra.temp.toFixed(1);
            const tempF = ((latestExtra.temp * 9/5) + 32).toFixed(1);
            if (preferredTempUnit === 'F') {
              tempHtml = `<div class="live-modal-dose-temp">${tempF}¬∞F</div>`;
            } else {
              tempHtml = `<div class="live-modal-dose-temp">${tempC}¬∞C</div>`;
            }
          }
        }
        
        doseEl.innerHTML = `
          <div class="live-modal-dose-value" style="color:${doseColor};">${primaryValue} <span style="font-size:0.45em;">${primaryUnit}</span></div>
          <div class="live-modal-dose-alt" style="color:${doseColor};">${altValue} ${altUnit}</div>
          ${lastSeen ? `<div class="live-modal-dose-time">${escapeHtml(lastSeen)}</div>` : ''}
          ${tempHtml}
        `;
        console.log('Dose display updated with:', primaryValue, primaryUnit);
      }
    } else {
      console.log('No series data available, data:', data);
    }
    
    // Update basic meta
    if (metaEl) {
      const metaParts = [buildDeviceMeta(merged)];
      const local = approximateLocalTime(merged.lat, merged.lon);
      if (local) metaParts.push('<div><strong>' + translate('live_marker_local_time') + ':</strong> ' + escapeHtml(local.text) + ' (' + escapeHtml(local.zone) + ')</div>');
      metaEl.innerHTML = metaParts.join('');
    }
    if (extraEl) extraEl.innerHTML = renderEnvironmentExtras(merged.liveExtra);

    const ranges = (data && data.ranges) ? data.ranges : {};
    
    const drawRange = (rangeKey) => {
      const series = data.series && data.series[rangeKey] ? data.series[rangeKey] : [];
      const extras = data.extraSeries && data.extraSeries[rangeKey] ? data.extraSeries[rangeKey] : null;
      const hasSeries = (series && series.length) || hasExtraSeries(extras);
      const rangeInfo = ranges && ranges[rangeKey] ? ranges[rangeKey] : null;
      
      const options = {};
      if (rangeInfo && typeof rangeInfo.start === 'number' && typeof rangeInfo.end === 'number') {
        options.start = rangeInfo.start;
        options.end = rangeInfo.end;
      }
      if (rangeInfo && typeof rangeInfo.bucketSeconds === 'number') {
        options.bucketSeconds = rangeInfo.bucketSeconds;
      }
      
      if (rangeKey === 'day') { options.tickUnit = 'hour'; options.tickSegments = 24; }
      else if (rangeKey === 'month') { options.tickUnit = 'day'; options.tickSegments = 24; }
      else if (rangeKey === 'all') { options.tickUnit = 'month'; options.tickSegments = 24; }

      if (canvas && hasSeries) {
        if (empty) empty.style.display = 'none';
        updateChartHeading(rangeKey, ranges);
        updateChartWindowLabel(rangeKey, ranges);
        drawLiveChart(canvas, series, extras, options);
      } else if (empty) {
        empty.textContent = translate('live_marker_no_data');
        empty.style.display = 'block';
      }
    };

    // Range button listeners
    const rangeBtns = document.querySelectorAll('.live-range-btn');
    rangeBtns.forEach(btn => {
      btn.onclick = () => {
        rangeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        canvas._zoomRanges = null; // Reset zoom when switching range
        drawRange(btn.dataset.range);
      };
    });

    // Temperature unit toggle
    const tempToggle = document.getElementById('tempUnitToggle');
    if (tempToggle) {
      tempToggle.textContent = preferredTempUnit === 'F' ? '¬∞F' : '¬∞C';
      tempToggle.classList.toggle('active', true);
      tempToggle.onclick = () => {
        preferredTempUnit = preferredTempUnit === 'C' ? 'F' : 'C';
        setCookie('tempUnit', preferredTempUnit, 365);
        tempToggle.textContent = preferredTempUnit === 'F' ? '¬∞F' : '¬∞C';
        
        // Update temperature display
        if (doseEl && data.extraSeries && data.extraSeries.day && data.extraSeries.day.length > 0) {
          const latestExtra = data.extraSeries.day[data.extraSeries.day.length - 1];
          if (latestExtra && latestExtra.temp !== null && latestExtra.temp !== undefined) {
            const tempC = latestExtra.temp.toFixed(1);
            const tempF = ((latestExtra.temp * 9/5) + 32).toFixed(1);
            const tempDisplay = preferredTempUnit === 'F' ? `${tempF}¬∞F` : `${tempC}¬∞C`;
            
            // Update just the temperature part
            const tempElement = doseEl.querySelector('.live-modal-dose-temp');
            if (tempElement) {
              tempElement.textContent = tempDisplay;
            }
          }
        }
        
        // Update environment section
        if (extraEl) {
          extraEl.innerHTML = renderEnvironmentExtras(merged.liveExtra);
        }
        
        // Redraw the chart with updated temperature unit
        const activeBtn = document.querySelector('.live-range-btn.active');
        if (activeBtn) {
          canvas._zoomRanges = null;
          drawRange(activeBtn.dataset.range);
        }
      };
    }

    // Default to 'day'
    drawRange('day');

  } catch (err) {
    if (descEl) descEl.textContent = translate('live_marker_history_error');
    if (empty) { empty.textContent = translate('live_marker_no_data'); empty.style.display = 'block'; }
  }
}

// Spectrum Modal Functions
function hideSpectrumModal() {
  const modal = document.getElementById('spectrumModal');
  if (modal) modal.style.display = 'none';
}

function identifyIsotopesInSpectrum(spectrum) {
  // Calculate energy values for each channel
  const cal = spectrum.calibration || { a: 0, b: spectrum.energyMaxKeV / spectrum.channelCount, c: 0 };
  const energies = spectrum.channels.map((_, i) => cal.a + cal.b * i + cal.c * i * i);

  // Find peaks in the spectrum (simple threshold-based detection)
  const maxCount = Math.max(...spectrum.channels);
  const threshold = maxCount * 0.1; // Peaks must be at least 10% of max
  const peaks = [];

  for (let i = 1; i < spectrum.channels.length - 1; i++) {
    const count = spectrum.channels[i];
    const prevCount = spectrum.channels[i - 1];
    const nextCount = spectrum.channels[i + 1];

    // Check if this is a local maximum above threshold
    if (count > threshold && count > prevCount && count > nextCount) {
      peaks.push({ energy: energies[i], count: count });
    }
  }

  // Match peaks to isotopes
  const detectedIsotopes = new Map(); // Use Map to avoid duplicates
  const tolerance = 15; // keV tolerance for matching

  peaks.forEach(peak => {
    const isotope = findIsotopeByEnergy(peak.energy, tolerance);
    if (isotope) {
      if (!detectedIsotopes.has(isotope)) {
        detectedIsotopes.set(isotope, []);
      }
      detectedIsotopes.get(isotope).push(peak.energy.toFixed(1));
    }
  });

  // Convert Map to array of objects
  const result = [];
  detectedIsotopes.forEach((energies, isotope) => {
    result.push({
      isotope: isotope,
      energies: energies
    });
  });

  return result;
}

async function openSpectrumModal(markerID, fallbackMarker) {
  const modal = document.getElementById('spectrumModal');
  if (!modal) return;
  modal.style.display = 'flex';

  const titleEl = document.getElementById('spectrumModalTitle');
  const descEl = document.getElementById('spectrumModalDescription');
  const metaEl = document.getElementById('spectrumModalMeta');
  const closeBtn = document.getElementById('spectrumModalClose');
  const emptyEl = document.getElementById('spectrumChartEmpty');
  const canvas = document.getElementById('spectrumChart');

  if (titleEl) titleEl.textContent = 'Gamma Spectrum';
  if (descEl) descEl.textContent = 'Energy spectrum from scintillator detector';
  if (emptyEl) { emptyEl.textContent = ''; emptyEl.style.display = 'none'; }

  // Set up download buttons
  const jsonBtn = document.getElementById('spectrumDownloadJSON');
  const csvBtn = document.getElementById('spectrumDownloadCSV');
  if (jsonBtn) {
    jsonBtn.onclick = function() { downloadSpectrum(markerID, 'json'); };
  }
  if (csvBtn) {
    csvBtn.onclick = function() { downloadSpectrum(markerID, 'csv'); };
  }

  // Build metadata
  if (metaEl && fallbackMarker) {
    const parts = [];
    const primaryValue = formatPrimaryUnit(fallbackMarker.doseRate);
    const secondaryValue = formatSecondaryUnit(fallbackMarker.doseRate);
    const primaryUnit = getPrimaryUnitLabel();
    const secondaryUnit = getSecondaryUnitLabel();
    parts.push(`<div><strong>Dose Rate:</strong> ${primaryValue} ${primaryUnit} (${secondaryValue} ${secondaryUnit})</div>`);
    if (fallbackMarker.date) {
      const date = new Date(fallbackMarker.date * 1000);
      parts.push(`<div><strong>Captured:</strong> ${date.toLocaleString()}</div>`);
    }
    if (fallbackMarker.trackID) {
      parts.push(`<div><strong>Track ID:</strong> ${fallbackMarker.trackID}</div>`);
    }
    metaEl.innerHTML = parts.join('');
  }

  // Clear canvas
  if (canvas) {
    const ctx = canvas.getContext('2d');
    if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Fetch and draw spectrum
  try {
    const spectrum = await fetchSpectrum(markerID);
    if (spectrum && canvas) {
      // Store spectrum data globally for redrawing with highlights
      window.currentSpectrum = spectrum;
      window.currentSpectrumCanvas = canvas;

      drawSpectrumChart(canvas, spectrum);

      // Display complete isotope reference list
      const isotopeList = buildIsotopeReferenceList();
      const isotopeListEl = document.getElementById('spectrumIsotopeList');

      if (isotopeListEl) {
        // Create two-column compact layout with hover functionality
        isotopeListEl.innerHTML = isotopeList.map(item => {
          const isotopeColor = getIsotopeColor(item.name);
          return `
          <div class="isotope-item" data-isotope="${item.name}" style="display: flex; align-items: baseline; gap: 6px; font-size: var(--font-size-sm); line-height: 1.6; cursor: pointer; padding: 4px; border-radius: 4px; transition: background 0.2s;">
            <span style="font-weight: 600; color: ${isotopeColor}; min-width: 90px;">${item.name}:</span>
            <span style="font-family: monospace; color: var(--modal-text); opacity: 0.85;">${item.energies} keV</span>
          </div>
        `;
        }).join('');

        // Add hover event listeners to isotope items
        const isotopeItems = isotopeListEl.querySelectorAll('.isotope-item');
        isotopeItems.forEach(item => {
          item.addEventListener('mouseenter', function() {
            const isotopeName = this.getAttribute('data-isotope');
            highlightIsotopeOnChart(isotopeName);
            // Add background highlight to the hovered item
            this.style.background = 'var(--control-bg)';
          });

          item.addEventListener('mouseleave', function() {
            clearIsotopeHighlight();
            // Remove background highlight
            this.style.background = 'transparent';
          });
        });
      }
    } else if (emptyEl) {
      emptyEl.textContent = 'No spectrum data available';
      emptyEl.style.display = 'block';
    }
  } catch (err) {
    console.error('Error loading spectrum:', err);
    if (emptyEl) {
      emptyEl.textContent = 'Error loading spectrum data';
      emptyEl.style.display = 'block';
    }
  }
}

// Isotope energy lookup table (keV)
const isotopeEnergyTable = [
  { isotope: 'H-3 (Tritium)', energy: 18.6 },
  { isotope: 'Am-241', energy: 59.5 },
  { isotope: 'Ba-133', energy: 81.0 },
  { isotope: 'Ba-133', energy: 276.4 },
  { isotope: 'Ba-133', energy: 302.9 },
  { isotope: 'Ba-133', energy: 356.0 },
  { isotope: 'Ba-133', energy: 383.8 },
  { isotope: 'Ra-226', energy: 186.2 },
  { isotope: 'Ra-226', energy: 242.0 },
  { isotope: 'Th-232', energy: 238.6 },
  { isotope: 'Ra-226', energy: 295.2 },
  { isotope: 'Ra-226', energy: 351.9 },
  { isotope: 'I-131', energy: 364.5 },
  { isotope: 'Annihilation', energy: 511.0 },
  { isotope: 'Th-232', energy: 583.2 },
  { isotope: 'I-131', energy: 637.0 },
  { isotope: 'Cs-137', energy: 661.7 },
  { isotope: 'Th-232', energy: 911.2 },
  { isotope: 'Co-60', energy: 1173.2 },
  { isotope: 'Na-22', energy: 1274.5 },
  { isotope: 'Co-60', energy: 1332.5 },
  { isotope: 'K-40', energy: 1460.8 },
  { isotope: 'Th-232', energy: 2614.5 }
];

// Get color for a specific isotope
function getIsotopeColor(isotopeName) {
  const isotopeColors = {
    'K-40': '#FFD700',           // Gold
    'Cs-137': '#00FF00',         // Green
    'I-131': '#9370DB',          // Medium Purple
    'Co-60': '#4169E1',          // Royal Blue
    'Th-232': '#FF8C00',         // Dark Orange
    'Ra-226': '#FF4500',         // Orange Red
    'Ba-133': '#00CED1',         // Dark Turquoise
    'Am-241': '#FF1493',         // Deep Pink
    'Na-22': '#32CD32',          // Lime Green
    'H-3 (Tritium)': '#87CEEB', // Sky Blue
    'Annihilation': '#FFFFFF'    // White
  };

  const color = isotopeColors[isotopeName] || '#FFD700';
  console.log('[COLOR DEBUG] Isotope:', isotopeName, '-> Color:', color);
  return color;
}

function findIsotopeByEnergy(energy, tolerance = 10) {
  // tolerance in keV - how close the energy needs to be to match
  for (let i = 0; i < isotopeEnergyTable.length; i++) {
    const entry = isotopeEnergyTable[i];
    if (Math.abs(entry.energy - energy) <= tolerance) {
      return entry.isotope;
    }
  }
  return null;
}

// Get all energy peaks for a given isotope
function getIsotopeEnergies(isotopeName) {
  const energies = [];
  for (let i = 0; i < isotopeEnergyTable.length; i++) {
    const entry = isotopeEnergyTable[i];
    if (entry.isotope === isotopeName) {
      energies.push(entry.energy);
    }
  }
  return energies;
}

function buildIsotopeReferenceList() {
  // Group energies by isotope
  const isotopeMap = new Map();

  isotopeEnergyTable.forEach(entry => {
    if (!isotopeMap.has(entry.isotope)) {
      isotopeMap.set(entry.isotope, []);
    }
    isotopeMap.get(entry.isotope).push(entry.energy);
  });

  // Convert to array and format
  const isotopes = [];
  isotopeMap.forEach((energies, isotope) => {
    isotopes.push({
      name: isotope,
      energies: energies.join(', ')
    });
  });

  return isotopes;
}

// Highlight isotope peaks on chart
function highlightIsotopeOnChart(isotopeName) {
  if (!window.currentSpectrum || !window.currentSpectrumCanvas) return;

  const energies = getIsotopeEnergies(isotopeName);
  const color = getIsotopeColor(isotopeName);

  // Redraw chart with highlights
  drawSpectrumChart(window.currentSpectrumCanvas, window.currentSpectrum, energies, color);
}

// Clear isotope highlights
function clearIsotopeHighlight() {
  if (!window.currentSpectrum || !window.currentSpectrumCanvas) return;

  // Redraw chart without highlights
  drawSpectrumChart(window.currentSpectrumCanvas, window.currentSpectrum);
}

function drawSpectrumChart(canvas, spectrum, highlightEnergies = null, highlightColor = null, zoomRanges = null) {
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (width === 0 || height === 0) return;

  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, width, height);

  const colors = chartColors();
  canvas.style.background = colors.background;

  // Calculate energy values for each channel
  const cal = spectrum.calibration || { a: 0, b: spectrum.energyMaxKeV / spectrum.channelCount, c: 0 };
  const energies = spectrum.channels.map((_, i) => cal.a + cal.b * i + cal.c * i * i);

  const maxCount = Math.max(...spectrum.channels);
  const maxEnergy = Math.max(...energies);

  // Define plot area with padding (similar to drawLiveChart)
  const leftPad = 70;
  const rightPad = 20;
  const topPad = 20;
  const bottomPad = 44;

  const plotLeft = leftPad;
  const plotRight = width - rightPad;
  const plotTop = topPad;
  const plotBottom = height - bottomPad;
  const plotW = Math.max(plotRight - plotLeft, 10);
  const plotH = Math.max(plotBottom - plotTop, 10);

  // Data ranges - use zoom ranges if provided, otherwise use full range
  const defaultRanges = { minX: 0, maxX: maxEnergy, minY: 0, maxY: maxCount };
  canvas._defaultZoomRanges = defaultRanges; // Store for reset
  const ranges = zoomRanges || canvas._zoomRanges || defaultRanges;
  let minX = ranges.minX;
  let maxX = ranges.maxX;
  let minY = ranges.minY;
  let maxY = ranges.maxY;

  // Recalculate minY and maxY based on visible data when zoomed
  if (zoomRanges || canvas._zoomRanges) {
    let visibleMaxCount = 0;
    for (let i = 0; i < energies.length; i++) {
      if (energies[i] >= minX && energies[i] <= maxX) {
        visibleMaxCount = Math.max(visibleMaxCount, spectrum.channels[i]);
      }
    }
    if (visibleMaxCount > 0) {
      maxY = visibleMaxCount;
      minY = 0; // Always start at 0 for clear baseline
    }
  }

  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;

  // Draw axes
  ctx.strokeStyle = colors.grid;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(plotLeft, plotTop);
  ctx.lineTo(plotLeft, plotBottom);
  ctx.lineTo(plotRight, plotBottom);
  ctx.stroke();

  const fontTokens = resolveFontTokens();
  const fonts = {
    axisY: fontTokens.sm + ' ' + fontTokens.family,
    axisX: fontTokens.xs + ' ' + fontTokens.family,
    label: fontTokens.base + ' ' + fontTokens.family,
  };

  // Draw Y-axis (Counts) ticks and labels
  const ticksY = niceTicks(minY, maxY, 5);
  ctx.font = fonts.axisY;
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  ticksY.forEach(function(value) {
    if (!isFinite(value)) return;
    const y = plotBottom - ((value - minY) / rangeY) * plotH;
    // Draw grid line
    ctx.strokeStyle = colorWithAlpha(colors.grid, 0.5);
    ctx.beginPath();
    ctx.moveTo(plotLeft, y);
    ctx.lineTo(plotRight, y);
    ctx.stroke();
    // Draw label
    ctx.fillStyle = colors.text;
    ctx.fillText(Math.round(value).toString(), plotLeft - 8, y);
  });

  // Draw X-axis (Energy keV) ticks and labels
  const ticksX = niceTicks(minX, maxX, 6);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.font = fonts.axisX;
  const axisLabelY = height - 12;
  ticksX.forEach(function(value) {
    if (!isFinite(value)) return;
    const x = plotLeft + ((value - minX) / rangeX) * plotW;
    // Draw grid line
    ctx.strokeStyle = colorWithAlpha(colors.grid, 0.35);
    ctx.beginPath();
    ctx.moveTo(x, plotTop);
    ctx.lineTo(x, plotBottom);
    ctx.stroke();
    // Draw label
    ctx.fillStyle = colors.text;
    ctx.fillText(Math.round(value).toString(), x, plotBottom + 4);
  });

  // Draw axis label (Energy keV)
  ctx.fillStyle = colors.text;
  ctx.textAlign = 'center';
  ctx.font = fonts.axisX;
  ctx.fillText('Energy (keV)', plotLeft + plotW / 2, axisLabelY);

  // Draw spectrum line
  ctx.strokeStyle = colors.line;
  ctx.lineWidth = 1.5;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();

  let firstPoint = true;
  for (let i = 0; i < spectrum.channels.length; i++) {
    const energy = energies[i];
    const count = spectrum.channels[i];

    // Only draw points within the visible energy range
    if (energy < minX || energy > maxX) continue;

    const x = plotLeft + ((energy - minX) / rangeX) * plotW;
    const y = plotBottom - ((count - minY) / rangeY) * plotH;

    if (firstPoint) {
      ctx.moveTo(x, y);
      firstPoint = false;
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();

  // Draw isotope energy highlights if provided
  if (highlightEnergies && highlightEnergies.length > 0 && highlightColor) {
    ctx.strokeStyle = highlightColor;
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.7;
    ctx.setLineDash([8, 4]); // Dashed line pattern

    highlightEnergies.forEach(energy => {
      if (energy >= minX && energy <= maxX) {
        const x = plotLeft + ((energy - minX) / rangeX) * plotW;

        // Draw vertical line
        ctx.beginPath();
        ctx.moveTo(x, plotTop);
        ctx.lineTo(x, plotBottom);
        ctx.stroke();

        // Draw energy label at top
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = highlightColor;
        ctx.font = 'bold ' + fonts.axisX;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(Math.round(energy) + ' keV', x, plotTop - 4);
        ctx.globalAlpha = 0.7;
      }
    });

    // Reset line dash and alpha
    ctx.setLineDash([]);
    ctx.globalAlpha = 1.0;
  }

  // Add interactive tooltip
  let tooltipDiv = document.getElementById('spectrumTooltip');
  if (!tooltipDiv) {
    tooltipDiv = document.createElement('div');
    tooltipDiv.id = 'spectrumTooltip';
    tooltipDiv.style.cssText = `
      position: absolute;
      display: none;
      background: var(--modal-bg);
      color: var(--modal-text);
      border: 1px solid var(--modal-text);
      border-radius: 4px;
      padding: 6px 10px;
      font-size: var(--font-size-sm);
      pointer-events: none;
      z-index: 10000;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    document.body.appendChild(tooltipDiv);
  }

  // Remove old event listeners if they exist
  const oldMouseMove = canvas._spectrumMouseMove;
  const oldMouseOut = canvas._spectrumMouseOut;
  if (oldMouseMove) canvas.removeEventListener('mousemove', oldMouseMove);
  if (oldMouseOut) canvas.removeEventListener('mouseout', oldMouseOut);

  // Save the original canvas image data for efficient redrawing
  let baseChartImage = null;
  // Capture the base chart after first draw
  setTimeout(() => {
    baseChartImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
    console.log('[Spectrum DEBUG] Base chart image captured:', canvas.width, 'x', canvas.height);
  }, 0);

  // Track currently hovered isotope
  let currentHoverIsotope = null;

  // Function to draw energy peak markers for an isotope
  const drawIsotopeMarkers = function(isotopeName) {
    console.log('[Spectrum DEBUG] drawIsotopeMarkers called for:', isotopeName, 'baseChartImage exists:', !!baseChartImage);
    if (!isotopeName || !baseChartImage) {
      console.log('[Spectrum DEBUG] Returning early - no isotope or no base image');
      return;
    }

    // Restore base chart
    ctx.putImageData(baseChartImage, 0, 0);

    const isotopeEnergies = getIsotopeEnergies(isotopeName);
    console.log('[Spectrum DEBUG] Isotope energies for', isotopeName, ':', isotopeEnergies);
    const colors = chartColors();
    const isotopeColor = getIsotopeColor(isotopeName);
    console.log('[Spectrum DEBUG] Using color for', isotopeName, ':', isotopeColor);

    // Draw vertical lines for each energy peak
    isotopeEnergies.forEach(peakEnergy => {
      // Convert energy to canvas x position
      const xPos = plotLeft + ((peakEnergy - minX) / rangeX) * plotW;

      // Only draw if within visible range
      if (xPos >= plotLeft && xPos <= plotRight) {
        ctx.save();
        ctx.strokeStyle = isotopeColor;
        console.log('[Spectrum DEBUG] Drawing line with color:', ctx.strokeStyle, 'for', isotopeName);
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); // Dashed line
        ctx.globalAlpha = 0.7;

        ctx.beginPath();
        ctx.moveTo(xPos, plotTop);
        ctx.lineTo(xPos, plotBottom);
        ctx.stroke();

        // Draw energy label at top
        ctx.fillStyle = colors.text || '#e0e0e0';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.globalAlpha = 1.0;
        ctx.fillText(peakEnergy.toFixed(1) + ' keV', xPos, plotTop - 5);

        ctx.restore();
      }
    });
  };

  // Mouse move handler
  // Zoom state shared between handlers
  let zoomStart = null;
  let isZooming = false;

  const handleMouseMove = function(e) {
    // If zooming, handle zoom drawing instead
    if (isZooming && zoomStart && baseChartImage) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Restore base chart image
      ctx.putImageData(baseChartImage, 0, 0);

      // Draw selection rectangle
      ctx.strokeStyle = '#FFD700';
      ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
      ctx.lineWidth = 2;
      const w = x - zoomStart.x;
      const h = y - zoomStart.y;
      ctx.fillRect(zoomStart.x, zoomStart.y, w, h);
      ctx.strokeRect(zoomStart.x, zoomStart.y, w, h);

      e.preventDefault();
      return;
    }

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Check if mouse is within plot area
    if (mouseX < plotLeft || mouseX > plotRight || mouseY < plotTop || mouseY > plotBottom) {
      tooltipDiv.style.display = 'none';
      // Clear markers if moving out of plot area
      if (currentHoverIsotope !== null && baseChartImage) {
        currentHoverIsotope = null;
        ctx.putImageData(baseChartImage, 0, 0); // Restore base chart
      }
      return;
    }

    // Convert mouse position to data coordinates
    const dataX = minX + ((mouseX - plotLeft) / plotW) * rangeX;

    // Find closest data point
    let closestIdx = 0;
    let minDist = Infinity;
    for (let i = 0; i < energies.length; i++) {
      const dist = Math.abs(energies[i] - dataX);
      if (dist < minDist) {
        minDist = dist;
        closestIdx = i;
      }
    }

    const energy = energies[closestIdx];
    const count = spectrum.channels[closestIdx];

    // Check if energy matches known isotope
    const isotope = findIsotopeByEnergy(energy, 10);
    console.log('[Spectrum DEBUG] Hover at', energy.toFixed(1), 'keV, detected isotope:', isotope);

    // If isotope changed, redraw markers
    if (isotope !== currentHoverIsotope) {
      console.log('[Spectrum DEBUG] Isotope changed from', currentHoverIsotope, 'to', isotope);
      currentHoverIsotope = isotope;
      // Draw markers for new isotope (or clear if null)
      if (isotope) {
        drawIsotopeMarkers(isotope);
      } else if (baseChartImage) {
        console.log('[Spectrum DEBUG] Clearing markers, restoring base chart');
        ctx.putImageData(baseChartImage, 0, 0); // Restore base chart
      }
    }

    // Update tooltip content and position
    let tooltipContent = '';
    if (isotope) {
      const allEnergies = getIsotopeEnergies(isotope);
      const energyList = allEnergies.map(e => e.toFixed(1)).join(', ');
      const isotopeColor = getIsotopeColor(isotope);
      console.log('[Spectrum DEBUG] Building tooltip for', isotope, '- all energies:', energyList);
      tooltipContent = `<div style="color: ${isotopeColor}; font-weight: bold;">${isotope}</div><strong>${energy.toFixed(1)} keV</strong><br>Counts: ${count}<br><span style="font-size: 0.9em;">Other peaks: ${energyList} keV</span>`;
    } else {
      tooltipContent = `<strong>${energy.toFixed(1)} keV</strong><br>Counts: ${count}`;
    }

    tooltipDiv.innerHTML = tooltipContent;
    tooltipDiv.style.display = 'block';
    tooltipDiv.style.left = (e.clientX + 10) + 'px';
    tooltipDiv.style.top = (e.clientY + 10) + 'px';
  };

  // Mouse out handler
  const handleMouseOut = function() {
    tooltipDiv.style.display = 'none';
    // Clear markers when mouse leaves canvas
    if (currentHoverIsotope !== null && baseChartImage) {
      currentHoverIsotope = null;
      ctx.putImageData(baseChartImage, 0, 0); // Restore base chart
    }
  };

  // Store handlers on canvas so we can remove them later
  canvas._spectrumMouseMove = handleMouseMove;
  canvas._spectrumMouseOut = handleMouseOut;

  // Add event listeners
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseout', handleMouseOut);

  // Zoom functionality
  const handleZoomStart = function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Check if click is within plot area
    if (x >= plotLeft && x <= plotRight && y >= plotTop && y <= plotBottom) {
      isZooming = true;
      zoomStart = { x, y };
      e.preventDefault();
    }
  };

  const handleZoomEnd = function(e) {
    if (!isZooming || !zoomStart) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Calculate new zoom ranges
    const x1 = Math.min(zoomStart.x, x);
    const x2 = Math.max(zoomStart.x, x);
    const y1 = Math.min(zoomStart.y, y);
    const y2 = Math.max(zoomStart.y, y);

    // Only zoom if selection is large enough (more than 10 pixels)
    if (Math.abs(x2 - x1) > 10 && Math.abs(y2 - y1) > 10) {
      const newMinX = minX + ((x1 - plotLeft) / plotW) * rangeX;
      const newMaxX = minX + ((x2 - plotLeft) / plotW) * rangeX;
      const newMaxY = maxY - ((y1 - plotTop) / plotH) * rangeY;
      const newMinY = maxY - ((y2 - plotTop) / plotH) * rangeY;

      canvas._zoomRanges = {
        minX: Math.max(0, newMinX),
        maxX: Math.min(maxEnergy, newMaxX),
        minY: Math.max(0, newMinY),
        maxY: Math.min(maxCount, newMaxY)
      };

      // Redraw with new zoom
      drawSpectrumChart(canvas, spectrum, highlightEnergies, highlightColor);
    } else {
      // Selection too small, just redraw without zoom change
      drawSpectrumChart(canvas, spectrum, highlightEnergies, highlightColor, ranges);
    }

    isZooming = false;
    zoomStart = null;
    e.preventDefault();
  };

  const handleZoomReset = function(e) {
    if (e.detail === 2) { // Double click
      canvas._zoomRanges = null;
      drawSpectrumChart(canvas, spectrum, highlightEnergies, highlightColor);
      e.preventDefault();
    }
  };

  // Remove old zoom handlers if they exist
  if (canvas._zoomStart) canvas.removeEventListener('mousedown', canvas._zoomStart);
  if (canvas._zoomEnd) canvas.removeEventListener('mouseup', canvas._zoomEnd);
  if (canvas._zoomReset) canvas.removeEventListener('click', canvas._zoomReset);

  // Store and add zoom handlers
  canvas._zoomStart = handleZoomStart;
  canvas._zoomEnd = handleZoomEnd;
  canvas._zoomReset = handleZoomReset;

  canvas.addEventListener('mousedown', handleZoomStart);
  canvas.addEventListener('mouseup', handleZoomEnd);
  canvas.addEventListener('click', handleZoomReset);

  // Change cursor to crosshair in plot area
  canvas.style.cursor = 'crosshair';
}


let debounceTimeout;

function debounceUpdateMarkers() {
  clearTimeout(debounceTimeout);
  debounceTimeout = setTimeout(updateMarkers, 300);
}

function adjustMarkerRadius() {
  var zoomLevel = map.getZoom();
  const nowSec = Date.now() / 1000;
  for (let key in circleMarkers) {
    let marker = circleMarkers[key];
    if (marker.isRealtime) {
      // Recompute icon style so stale sensors fade without user interaction.
      const icon = buildRealtimeIcon(marker, zoomLevel, nowSec);
      if (!icon) {
        map.removeLayer(marker);
        delete circleMarkers[key];
        continue;
      }
      marker.setIcon(L.divIcon({className:'', html: icon.html, iconSize:[icon.size, icon.size], iconAnchor:[icon.radius, icon.radius]}));
    } else if (typeof marker.setRadius === 'function') {
      // Circle markers scale by adjusting radius directly
      let newRadius = getRadius(marker.doseRate, zoomLevel);
      marker.setRadius(newRadius);
    }
  }
}

/* -----------------------------------------------------------------
 *  viewTrack() ‚Äî switch to single-track mode.
 *  Set currentTrackID = trackID before changing window.location.
 * -----------------------------------------------------------------*/
function viewTrack(trackID) {
  currentTrackID = trackID;   // new
  isTrackView    = true;

  const layer  = map.hasLayer(googleSatellite) ? 'Google Satellite'
    : 'OpenStreetMap';

  // Don't include bounds in URL - let the frontend calculate real bounds from loaded markers
  const trackURL = `/trackid/${trackID}?layer=${encodeURIComponent(layer)}`;

  window.location.href = trackURL;
}


function setBaseLayer(layerName) {
  if (layerName === 'Google Satellite') {
    if (map.hasLayer(osmLayer))            map.removeLayer(osmLayer);
    if (!map.hasLayer(googleSatellite))    googleSatellite.addTo(map);
  } else {
    if (map.hasLayer(googleSatellite))     map.removeLayer(googleSatellite);
    if (!map.hasLayer(osmLayer))           osmLayer.addTo(map);
  }
}

// markShortLinkFocusReady flips the readiness flag once the user keeps the
// page focused long enough. Delaying the readiness ensures /api/shorten is
// only reached once a visitor pauses, avoiding noisy calls while they zoom.
function markShortLinkFocusReady() {
  shortLinkFocusReady = true;
  flushPendingShortLink();
}

// handleShortLinkFocus starts a short delay after the user focuses the page so
// intermediate zoom steps never trigger /api/shorten. The delay gives the
// visitor time to stop at the zoom level they actually want to share.
function handleShortLinkFocus() {
  shortLinkFocusReady = false;
  if (shortLinkFocusDelayTimer) {
    clearTimeout(shortLinkFocusDelayTimer);
  }
  shortLinkFocusDelayTimer = setTimeout(() => {
    shortLinkFocusDelayTimer = null;
    markShortLinkFocusReady();
  }, shortLinkFocusDelayMs);
}

// handleShortLinkBlur resets readiness immediately on blur so returning to the
// tab always waits for the focus grace period. This keeps outbound shorten
// requests aligned with intentional interaction.
function handleShortLinkBlur() {
  shortLinkFocusReady = false;
  if (shortLinkFocusDelayTimer) {
    clearTimeout(shortLinkFocusDelayTimer);
    shortLinkFocusDelayTimer = null;
  }
}

// flushPendingShortLink sends the queued /api/shorten request only when the
// focus delay has elapsed and the URL differs from the last confirmed target.
// Keeping this narrow prevents redundant backend calls while people are still
// zooming toward their desired level.
function flushPendingShortLink() {
  if (!shortLinkBox) return;
  if (!shortLinkFocusReady) return;
  if (!shortLinkPendingUrl) return;
  if (shortLinkPendingUrl === lastShortLinkFull) {
    shortLinkPendingUrl = '';
    return;
  }
  const target = shortLinkPendingUrl;
  shortLinkPendingUrl = '';
  requestShortLink(target);
}

function scheduleShortLinkRefresh() {
  if (!shortLinkBox) return;
  const full = window.location.href;
  if (!full) {
    return;
  }
  shortLinkPendingUrl = full;
  if (shortLinkTimer) {
    clearTimeout(shortLinkTimer);
  }
  shortLinkTimer = setTimeout(() => {
    shortLinkTimer = null;
    flushPendingShortLink();
  }, shortLinkIdleDelayMs);
}

function requestShortLink(fullURL) {
  if (!shortLinkBox) return;
  pendingShortLinkFull = fullURL;

  let controller = null;
  if (typeof AbortController !== 'undefined') {
    if (shortLinkAbort) {
      shortLinkAbort.abort();
    }
    controller = new AbortController();
    shortLinkAbort = controller;
  }

  const options = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ url: fullURL, commit: false })
  };
  if (controller) {
    options.signal = controller.signal;
  }

  fetch('/api/shorten', options)
    .then(response => {
      if (!response.ok) {
        throw new Error('shorten failed: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      if (pendingShortLinkFull !== fullURL) {
        return;
      }
      if (!data || !data.short || !data.target) {
        throw new Error('shorten response missing URL');
      }
      lastShortLinkFull = data.target;
      pendingShortLinkFull = '';
      if (controller === shortLinkAbort) {
        shortLinkAbort = null;
      }
      applyShortLink(data);
    })
    .catch(err => {
      if (err && err.name === 'AbortError') {
        return;
      }
      if (pendingShortLinkFull === fullURL) {
        pendingShortLinkFull = '';
        hideShortLink();
      }
      if (controller === shortLinkAbort) {
        shortLinkAbort = null;
      }
      console.error('short link fetch failed', err);
    });
}

function applyShortLink(details) {
  if (!shortLinkBox || !details) return;
  const shortURL = details.short || '';
  const code = details.code || '';
  const target = details.target || '';
  const stored = details.stored ? 'true' : 'false';
  if (!shortURL || !target) {
    hideShortLink();
    return;
  }
  shortLinkBox.style.display = 'block';
  shortLinkBox.textContent = shortURL;
  shortLinkBox.dataset.href = shortURL;
  shortLinkBox.dataset.code = code;
  shortLinkBox.dataset.target = target;
  shortLinkBox.dataset.persisted = stored;
}

function hideShortLink() {
  if (!shortLinkBox) return;
  if (window.__hideShortLinkHint) {
    window.__hideShortLinkHint();
  }
  shortLinkBox.style.display = 'none';
  delete shortLinkBox.dataset.href;
  delete shortLinkBox.dataset.code;
  delete shortLinkBox.dataset.target;
  delete shortLinkBox.dataset.persisted;
}

// finalizeShortLink persists the reserved code only after the visitor copies it.
// Returning a promise keeps the UI non-blocking while honoring the "share memory
// by communicating" proverb ‚Äî the page communicates with the backend instead of
// toggling global flags.
function finalizeShortLink() {
  if (!shortLinkBox) {
    return Promise.reject(new Error('short link box missing'));
  }
  const persisted = shortLinkBox.dataset.persisted === 'true';
  const href = shortLinkBox.dataset.href || '';
  const target = shortLinkBox.dataset.target || '';
  const code = shortLinkBox.dataset.code || '';
  if (!target) {
    return Promise.reject(new Error('missing short link target'));
  }
  if (persisted && href) {
    return Promise.resolve(href);
  }
  if (shortLinkCommitPromise) {
    return shortLinkCommitPromise;
  }

  const payload = { url: target, commit: true };
  if (code) {
    payload.code = code;
  }

  const options = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  };

  const pending = fetch('/api/shorten', options)
    .then(response => {
      if (!response.ok) {
        throw new Error('commit failed: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      if (!data || !data.short || !data.target) {
        throw new Error('shorten response missing URL');
      }
      lastShortLinkFull = data.target;
      pendingShortLinkFull = '';
      applyShortLink(data);
      return data.short;
    });

  shortLinkCommitPromise = pending;
  pending.finally(() => {
    if (shortLinkCommitPromise === pending) {
      shortLinkCommitPromise = null;
    }
  });
  return pending;
}

// copyShortLinkToClipboard waits for the backend to confirm persistence so
// users never copy a dangling preview link. The clipboard work stays inside the
// fulfilled branch to avoid race conditions when multiple copy attempts happen.
function copyShortLinkToClipboard() {
  if (!shortLinkBox) return;
  finalizeShortLink()
    .then(link => {
      if (!link) {
        throw new Error('empty short link');
      }

      const signalSuccess = () => {
        if (!shortLinkBox) return;
        shortLinkBox.classList.add('copied');
        setTimeout(() => shortLinkBox.classList.remove('copied'), 600);
      };

      const fallbackCopy = () => {
        const textarea = document.createElement('textarea');
        textarea.value = link;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'fixed';
        textarea.style.top = '-1000px';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          if (document.execCommand('copy')) {
            signalSuccess();
          }
        } catch (err) {
          console.error('copy failed', err);
        } finally {
          document.body.removeChild(textarea);
        }
      };

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(link)
          .then(signalSuccess)
          .catch(() => fallbackCopy());
      } else {
        fallbackCopy();
      }
    })
    .catch(err => {
      console.error('finalize short link failed', err);
    });
}

// Locate the nearest marker exceeding 30 ¬µR/h (0.30 ¬µSv/h) so the user can
// immediately see the closest high reading relative to their position.
function findNearestDanger(userLatLng) {
  if (!map || !userLatLng) return null;
  const threshold = 0.30; // ¬µSv/h
  let closest = null;
  let minDistance = Infinity;
  Object.values(circleMarkers).forEach(marker => {
    if (!marker || typeof marker.doseRate !== 'number') return;
    if (marker.doseRate < threshold) return;
    const dist = map.distance(userLatLng, marker.getLatLng());
    if (!isFinite(dist)) return;
    if (dist < minDistance) {
      minDistance = dist;
      closest = marker;
    }
  });
  return closest;
}

// Keep the map centered on the user while zooming just enough so the closest
// dangerous marker sits near the edge of the viewport. We never zoom out
// below level 10 to avoid losing city-level context.
function reframeAroundUser() {
  if (!storedUserCenter || !map) return;
  const userLatLng = L.latLng(storedUserCenter.lat, storedUserCenter.lon);
  const nearest = findNearestDanger(userLatLng);
  let targetZoom = Math.max(10, map.getZoom());

  if (nearest) {
    const bounds = L.latLngBounds(userLatLng, nearest.getLatLng());
    targetZoom = Math.max(10, map.getBoundsZoom(bounds, true));
  } else {
    targetZoom = Math.max(12, targetZoom);
  }

  map.setView(userLatLng, targetZoom);
  saveMapViewState();
  waitForDangerFit = false;
}

// Kick off a GeoIP fetch when browser geolocation is unavailable. The endpoint
// relies on the user's remote address, so the client does not have to expose
// extra personal data to third parties.
async function requestGeoIPFallback() {
  try {
    const resp = await fetch('/api/geoip', { method: 'GET' });
    if (!resp.ok || resp.status === 204) return null;
    const payload = await resp.json();
    if (typeof payload.lat !== 'number' || typeof payload.lon !== 'number') {
      return null;
    }
    return { lat: payload.lat, lon: payload.lon };
  } catch (err) {
    console.warn('geoip fallback failed', err);
    return null;
  }
}

// Try to resolve the user's position via browser APIs first, then fall back to
// GeoIP. We only run this when the operator enabled auto-locate and there is no
// stored or URL-provided state to respect.
function autoLocateUser() {
  if (!defaultCfg.autoLocate) return;
  if (isTrackView) {
    // Track views should remain centered on the track; skipping auto-locate
    // avoids overriding the live track stream with a GeoIP/geolocation guess.
    return;
  }
  const params = new URLSearchParams(window.location.search);
  const hasExplicitBounds = params.has('minLat') && params.has('minLon') && params.has('maxLat') && params.has('maxLon');
  if (hasExplicitBounds || loadMapViewState()) return;

  const usePosition = ({ lat, lon }) => {
    setStoredUserCenter(lat, lon);
    map.setView([lat, lon], Math.max(12, defaultCfg.zoom));
    saveMapViewState();
  };

  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      pos => {
        usePosition({ lat: pos.coords.latitude, lon: pos.coords.longitude });
      },
      async () => {
        const ipGuess = await requestGeoIPFallback();
        if (ipGuess) {
          usePosition(ipGuess);
        }
      },
      { enableHighAccuracy: false, timeout: 5000 }
    );
  } else {
    requestGeoIPFallback().then(guess => {
      if (guess) {
        usePosition(guess);
      }
    });
  }
}

function loadMapFromUrl() {
  const params = new URLSearchParams(window.location.search);
  const storedView = loadMapViewState();

  /* base layer from URL or default */
  const layer = decodeURIComponent(params.get('layer') || (storedView && storedView.layer) || defaultCfg.layer);
  setBaseLayer(layer);

  /* coloring scheme from URL or local storage */
  const coloringParam = params.get('coloring');
  if (coloringParam === 'chicha' || coloringParam === 'safecast') {
    currentColoring = coloringParam;
    saveColoringPreference(currentColoring);
  } else {
    currentColoring = loadColoringPreference();
  }
  radiationSteps = (currentColoring === 'chicha') ? schemeChicha : schemeSafecast;

  /* language from URL */
  const langParam = params.get('lang');
  if (langParam && translations[langParam]) {
    currentLang = langParam;
  }

  /* unit (coloring) from URL or local storage */
  const unitParam = params.get('unit');
  if (unitParam === 'uSv' || unitParam === 'uR') {
    currentUnit = unitParam;
    saveUnitPreference(currentUnit);
  } else {
    currentUnit = loadUnitPreference();
  }
  updateLegendDisplay();

  /* legend visibility from URL */
  const legendParam = params.get('legend');
  const legendBox = document.getElementById('legend');
  const unitToggle = document.getElementById('unitToggle');
  if (legendParam === '0') {
    if (legendBox) legendBox.style.display = 'none';
    if (unitToggle) unitToggle.style.display = 'none';
  } else if (legendParam === '1') {
    if (legendBox) legendBox.style.display = 'flex';
    if (unitToggle) unitToggle.style.display = 'block';
  }

  /* read remaining params */
  const minLat = parseFloat(params.get('minLat'));
  const minLon = parseFloat(params.get('minLon'));
  const maxLat = parseFloat(params.get('maxLat'));
  const maxLon = parseFloat(params.get('maxLon'));

  if (!isNaN(minLat) && !isNaN(minLon) && !isNaN(maxLat) && !isNaN(maxLon)) {
    map.fitBounds([[minLat, minLon], [maxLat, maxLon]]);
    adjustMarkerRadius();
  } else if (storedView) {
    map.setView([storedView.lat, storedView.lon], storedView.zoom);
    adjustMarkerRadius();
  } else if (isTrackView && trackBounds) {
    map.fitBounds(trackBounds);
  } else {
    map.setView([defaultCfg.lat, defaultCfg.lon], defaultCfg.zoom);
  }

  autoLocateUser();
}

function updateUrl() {
  var bounds = map.getBounds();
  var layer = map.hasLayer(googleSatellite) ? 'Google Satellite' : 'OpenStreetMap';
  var minLat = bounds.getSouthWest().lat.toFixed(5);
  var minLon = bounds.getSouthWest().lng.toFixed(5);
  var maxLat = bounds.getNorthEast().lat.toFixed(5);
  var maxLon = bounds.getNorthEast().lng.toFixed(5);
  var zoom = map.getZoom();

  var legendBox = document.getElementById('legend');
  var isLegendVisible = legendBox && legendBox.style.display !== 'none' ? '1' : '0';

  var newUrl = `${window.location.pathname}?minLat=${minLat}&minLon=${minLon}&maxLat=${maxLat}&maxLon=${maxLon}&zoom=${zoom}&layer=${encodeURIComponent(layer)}&unit=${currentUnit}&legend=${isLegendVisible}&coloring=${currentColoring}&lang=${currentLang}`;

  window.history.replaceState({}, '', newUrl);
  saveMapViewState();
  scheduleShortLinkRefresh();
}

function openServerPoster() {
  if (typeof updateUrl === 'function') { try { updateUrl(); } catch(_){} }
  var full = window.location.href;
  var dst  = '/qrpng?u=' + encodeURIComponent(full);
  window.open(dst, '_blank', 'noopener,noreferrer');
}

function initializeUIElements() {
  var locateButton = document.getElementById('locateButton');
  if (locateButton) {
    locateButton.addEventListener('click', centerMapToLocation);
  }
  var qrButton = document.getElementById('qrButton');
  if (qrButton) {
    qrButton.addEventListener('click', openServerPoster);
  }
  var backToAllButton = document.getElementById('backToAllButton');
  if (backToAllButton) {
    backToAllButton.addEventListener('click', function () {
      var params = (typeof getCurrentUrlParams === 'function') ? getCurrentUrlParams() : '';
      window.location.href = '/' + params;
    });
  }

  // Keep the download button aligned with the current track state even if
  // the DOM was injected before listeners finished binding.
  refreshDownloadLink();

  if (shortLinkBox) {
    const hint = translate('short_link_tooltip');
    shortLinkBox.setAttribute('title', hint);
    shortLinkBox.setAttribute('aria-label', hint);
    shortLinkBox.addEventListener('click', () => {
      copyShortLinkToClipboard();
    });
    shortLinkBox.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        copyShortLinkToClipboard();
      }
    });
  }

  // Respect focus state before requesting short links so intermediate zoom
  // steps do not bombard /api/shorten. Waiting for the focus grace period
  // keeps the backend in sync with intentional sharing.
  window.addEventListener('focus', handleShortLinkFocus);
  window.addEventListener('blur', handleShortLinkBlur);
  if (typeof document.hasFocus === 'function' && document.hasFocus()) {
    handleShortLinkFocus();
  }

  scheduleShortLinkRefresh();
}

function centerMapToLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      function(position) {
        var userLat = position.coords.latitude;
        var userLon = position.coords.longitude;

        setStoredUserCenter(userLat, userLon);
        map.setView([userLat, userLon], Math.max(12, defaultCfg.zoom));
        saveMapViewState();

        L.marker([userLat, userLon]).addTo(map)
          .bindPopup(translate("your_location")).openPopup();
      },
      async function(error) {
        switch(error.code) {
          case error.PERMISSION_DENIED:
            alert(translate("location_permission_denied"));
            break;
          case error.POSITION_UNAVAILABLE:
            alert(translate("location_unavailable"));
            break;
          case error.TIMEOUT:
            alert(translate("location_timeout"));
            break;
          default:
            alert(translate("location_error"));
            break;
        }
        const ipGuess = await requestGeoIPFallback();
        if (ipGuess) {
          setStoredUserCenter(ipGuess.lat, ipGuess.lon);
          map.setView([ipGuess.lat, ipGuess.lon], Math.max(12, defaultCfg.zoom));
          saveMapViewState();
        }
      }
    );
  } else {
    alert(translate("geolocation_not_supported"));
    requestGeoIPFallback().then(guess => {
      if (guess) {
        setStoredUserCenter(guess.lat, guess.lon);
        map.setView([guess.lat, guess.lon], Math.max(12, defaultCfg.zoom));
        saveMapViewState();
      }
    });
  }
}
    </script>

    <!-- File upload script -->
    <script>
      let backgroundRefreshTimer = null;
      function startBackgroundImportRefresh() {
        if (backgroundRefreshTimer) {
          clearInterval(backgroundRefreshTimer);
        }
        let rounds = 0;
        backgroundRefreshTimer = setInterval(() => {
          // Set flag to disable parallel tile loading during background refresh
          window.isBackgroundRefresh = true;
          updateMarkers();
          window.isBackgroundRefresh = false;
          rounds += 1;
          if (rounds >= 24) {
            clearInterval(backgroundRefreshTimer);
            backgroundRefreshTimer = null;
          }
        }, 5000);
      }

      function uploadFiles() {
        const fileInput  = document.getElementById('fileInput');
        const files      = fileInput.files;
        if (!files.length) {
          alert(translate('select_files'));
          return;
        }

        const fileOverlay          = document.getElementById('fileOverlay');
        const fileProgressContainer = document.getElementById('fileProgressContainer');
        fileProgressContainer.innerHTML = '';
        fileOverlay.style.display  = 'flex';

        /* counter and URL of last track */
        let completedUploads = 0;
        const totalFiles     = files.length;
        let lastTrackURL     = null;

        /* Create an XHR for each file but redirect only once */
        [...files].forEach(file => {
          /* --- visual progress elements --- */
          const fileBlock        = document.createElement('div');
          fileBlock.className    = 'file-progress';
          const fileName         = document.createElement('div');
          fileName.className     = 'file-name';
          fileName.innerText     = file.name;
          const progressBar      = document.createElement('div');
          progressBar.className  = 'progress-bar';
          const progressBarInner = document.createElement('div');
          progressBarInner.className = 'progress-bar-inner';
          progressBar.appendChild(progressBarInner);
          const serverProcessing = document.createElement('div');
          serverProcessing.className = 'server-processing';
          serverProcessing.innerText = translate('waiting_for_server');
          fileBlock.append(fileName, progressBar, serverProcessing);
          fileProgressContainer.appendChild(fileBlock);
          /* ------------------------------------------------- */

          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/upload', true);

          /* file upload progress */
          xhr.upload.onprogress = e => {
            if (e.lengthComputable) {
              const percent = (e.loaded / e.total) * 100;
              progressBarInner.style.width = percent + '%';
            }
          };

          /* handle server response */
          xhr.onload = () => {
            if (xhr.status === 200) {
              const response = JSON.parse(xhr.responseText);
              if (response.status === 'success') {
                lastTrackURL               = response.trackURL;   // remember
                serverProcessing.innerText = translate('processing_complete');
                serverProcessing.style.color = 'green';

                // Check if this is a spectrum file without coordinates
                if (response.needsCoordinates && response.trackID) {
                  serverProcessing.innerText = '‚ö† Needs location';
                  serverProcessing.style.color = 'orange';
                  // Show coordinate input dialog after all uploads complete
                  pendingCoordinateUpdate = { trackID: response.trackID, fileName: file.name, trackURL: response.trackURL };
                }
              } else if (response.status === 'processing') {
                lastTrackURL               = null;
                serverProcessing.innerText = translate('processing_complete');
                serverProcessing.style.color = 'green';
                startBackgroundImportRefresh();
              } else {
                serverProcessing.innerText = translate('error_processing_files');
                serverProcessing.style.color = 'red';
              }
            } else {
              serverProcessing.innerText = translate('error_during_upload');
              serverProcessing.style.color = 'red';
            }

            /* increment counter and redirect when done */
              completedUploads++;
            if (completedUploads === totalFiles) {
              setTimeout(() => {
                fileOverlay.style.display = 'none';

                // Show coordinate dialog if needed, otherwise redirect
                if (pendingCoordinateUpdate) {
                  showCoordinateDialog(pendingCoordinateUpdate.trackID, pendingCoordinateUpdate.fileName, pendingCoordinateUpdate.trackURL);
                } else if (lastTrackURL) {
                  window.location.href = lastTrackURL;
                } else {
                  updateMarkers();   // keep the map open for background imports
                }
              }, 700);
            }
          };

          /* send file */
            const formData = new FormData();
          formData.append('files[]', file);
          xhr.send(formData);
        });
      }
    </script>

    <!-- Coordinate Input Dialog Script -->
    <script>
      let pendingCoordinateUpdate = null;

      function showCoordinateDialog(trackID, fileName, trackURL) {
        pendingCoordinateUpdate = { trackID, fileName, trackURL };
        const dialog = document.getElementById('coordinateInputDialog');
        const statusEl = document.getElementById('coordInputStatus');
        const errorEl = document.getElementById('coordInputError');

        statusEl.textContent = `File: ${fileName}`;
        statusEl.style.display = 'block';
        errorEl.style.display = 'none';

        dialog.style.display = 'flex';

        // Pre-fill with current map center if available
        if (map) {
          const center = map.getCenter();
          document.getElementById('coordInputLat').value = center.lat.toFixed(6);
          document.getElementById('coordInputLon').value = center.lng.toFixed(6);
        }
      }

      function hideCoordinateDialog() {
        document.getElementById('coordinateInputDialog').style.display = 'none';
        pendingCoordinateUpdate = null;
      }

      async function submitCoordinates() {
        const latInput = document.getElementById('coordInputLat');
        const lonInput = document.getElementById('coordInputLon');
        const errorEl = document.getElementById('coordInputError');
        const submitBtn = document.getElementById('coordSubmitBtn');

        const lat = parseFloat(latInput.value);
        const lon = parseFloat(lonInput.value);

        // Validate inputs
        if (isNaN(lat) || isNaN(lon)) {
          errorEl.textContent = 'Please enter valid numbers for latitude and longitude.';
          errorEl.style.display = 'block';
          return;
        }

        if (lat < -90 || lat > 90) {
          errorEl.textContent = 'Latitude must be between -90 and 90.';
          errorEl.style.display = 'block';
          return;
        }

        if (lon < -180 || lon > 180) {
          errorEl.textContent = 'Longitude must be between -180 and 180.';
          errorEl.style.display = 'block';
          return;
        }

        if (!pendingCoordinateUpdate) {
          errorEl.textContent = 'No pending upload to update.';
          errorEl.style.display = 'block';
          return;
        }

        // Disable submit button during request
        submitBtn.disabled = true;
        submitBtn.textContent = 'Updating...';
        errorEl.style.display = 'none';

        try {
          const response = await fetch('/api/update-coordinates', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              trackID: pendingCoordinateUpdate.trackID,
              lat: lat,
              lon: lon
            })
          });

          const result = await response.json();

          if (response.ok && result.status === 'success') {
            // Success! Navigate to the track page
            const trackURL = pendingCoordinateUpdate ? pendingCoordinateUpdate.trackURL : null;
            hideCoordinateDialog();
            if (trackURL) {
              window.location.href = trackURL;
            } else {
              // Fallback to map location if trackURL is not available
              const zoom = 15;
              window.location.href = `/#${zoom}/${lat}/${lon}`;
            }
          } else {
            errorEl.textContent = result.error || 'Failed to update coordinates. Please try again.';
            errorEl.style.display = 'block';
          }
        } catch (error) {
          errorEl.textContent = 'Network error. Please check your connection and try again.';
          errorEl.style.display = 'block';
        } finally {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit Location';
        }
      }

      // Event listeners for coordinate dialog
      document.addEventListener('DOMContentLoaded', function() {
        // Submit button
        document.getElementById('coordSubmitBtn').addEventListener('click', submitCoordinates);

        // Cancel button
        document.getElementById('coordCancelBtn').addEventListener('click', hideCoordinateDialog);

        // Click on map button
        document.getElementById('coordMapPickBtn').addEventListener('click', function() {
          const statusEl = document.getElementById('coordInputStatus');
          statusEl.textContent = 'Click anywhere on the map to select a location...';

          // Store current pending update before hiding dialog
          const currentUpdate = pendingCoordinateUpdate;
          hideCoordinateDialog();

          // Add one-time click handler to map
          const mapClickHandler = function(e) {
            document.getElementById('coordInputLat').value = e.latlng.lat.toFixed(6);
            document.getElementById('coordInputLon').value = e.latlng.lng.toFixed(6);
            showCoordinateDialog(currentUpdate.trackID, currentUpdate.fileName, currentUpdate.trackURL);
            map.off('click', mapClickHandler);
          };

          map.once('click', mapClickHandler);
        });

        // Use current location button
        document.getElementById('coordCurrentBtn').addEventListener('click', function() {
          const errorEl = document.getElementById('coordInputError');

          if ('geolocation' in navigator) {
            errorEl.textContent = 'Getting your location...';
            errorEl.style.color = 'var(--isotope-highlight)';
            errorEl.style.display = 'block';

            navigator.geolocation.getCurrentPosition(
              function(position) {
                document.getElementById('coordInputLat').value = position.coords.latitude.toFixed(6);
                document.getElementById('coordInputLon').value = position.coords.longitude.toFixed(6);
                errorEl.style.display = 'none';
              },
              function(error) {
                errorEl.textContent = 'Could not get your location: ' + error.message;
                errorEl.style.color = '#f44336';
              }
            );
          } else {
            errorEl.textContent = 'Geolocation is not supported by your browser.';
            errorEl.style.color = '#f44336';
            errorEl.style.display = 'block';
          }
        });

        // Close dialog on Escape key
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape' && document.getElementById('coordinateInputDialog').style.display === 'flex') {
            hideCoordinateDialog();
          }
        });
      });
    </script>

    <!-- Theme toggle script -->
    <script>
      // Synchronize UI theme with map tiles and remember the choice for the session.
      document.addEventListener('DOMContentLoaded', function () {
        var sw = document.getElementById('themeSwitch');
        if (!sw) return;
        var media = window.matchMedia('(prefers-color-scheme: dark)');

        function applyTheme(theme) {
          document.documentElement.dataset.theme = theme; // switch CSS variables
          if (window.osmLayer) {
            window.osmLayer.setUrl(theme === 'dark' ? window.osmDark : window.osmLight);
          }
          sw.checked = theme === 'dark';
        }

        var storedTheme = sessionStorage.getItem('themePreference');
        var initialTheme = storedTheme ? storedTheme : (media.matches ? 'dark' : 'light');
        applyTheme(initialTheme); // set initial state

        sw.addEventListener('change', function () {
          var newTheme = this.checked ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });

        var toggleBox = document.getElementById('themeToggle');
        if (toggleBox) {
          toggleBox.addEventListener('keydown', function (ev) {
            if (ev.key === 'Enter' || ev.key === ' ') {
              ev.preventDefault();
              sw.checked = !sw.checked;
              sw.dispatchEvent(new Event('change'));
            }
          });
        }

        media.addEventListener('change', function (e) {
          var newTheme = e.matches ? 'dark' : 'light';
          applyTheme(newTheme);
          sessionStorage.setItem('themePreference', newTheme);
        });
      });
    </script>


<!--
  When the legend is clicked:
    ‚Ä¢ Fetch language-specific full text.
    ‚Ä¢ Split into paragraphs and decorate range lines with color squares.
    ‚Ä¢ Show modal; close on backdrop click for convenience.
-->
<script>
  // Build legend HTML with color squares for tooltip and modal.
  function buildLegendHTML(lang) {
    if (currentColoring === 'safecast') {
      var desc = translate('legend_safecast_desc');
      if (desc === 'legend_safecast_desc') {
        desc = "Safecast high-resolution radiation gradient (15 steps). Colors represent dose rates based on international background radiation standards.";
      }
      return '<p>' + desc + '</p>';
    }

    // Chicha 4-bin logic
    var key = 'legend_full_' + lang;
    var txt = translate(key);
    var parts = txt.split('\n\n');
    function stripBullet(line) {
      return line.replace(/^‚ñ†\s*/, '');
    }
    function square(color) {
      return '<span class="legend-square" style="background:' + color + ';"></span>';
    }
    return parts.map(function(p){
      var lines = p.split('\n').map(function(line){
        // These thresholds are matched by text in translations
        if (line.includes('0‚Äì11')) return square('#008000') + stripBullet(line);
        if (line.includes('11‚Äì30')) return square('#FFD700') + stripBullet(line);
        if (line.includes('30‚Äì100')) return square('#FF4500') + stripBullet(line);
        if (line.includes('>100')) return square('#000000') + stripBullet(line);
        return line;
      }).join('<br>');
      return '<p style="margin:0 0 1em 0;">' + lines + '</p>';
    }).join('');
  }

  // Display the full legend text in current language.
  // Exposed so marker popups reuse the same modal.
  function openLegendModal() {
    if (window.__hideLegendHint) {
      window.__hideLegendHint();
    }
    var lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
    var html = buildLegendHTML(lang);
    var box = document.getElementById('legendText');
    if (box) box.innerHTML = html;
    var modal = document.getElementById('legendModal');
    if (modal) modal.style.display = 'flex';
  }

  // Build HTML for info modal from translation text
  function buildInfoHTML(txt) {
    return txt.split('\n\n').map(function(p){
      return '<p style="margin:0 0 1em 0;">' + p.split('\n').join('<br>') + '</p>';
    }).join('');
  }

  // Turn license mentions into modal triggers so readers stay on the map page.
  function decorateLicenseLinks(txt) {
    if (typeof txt !== 'string' || !txt) {
      return txt;
    }
    var withMitAnchor = txt.replace(/<a[^>]*href=\u0022\/LICENSE\u0022[^>]*>([\s\S]*?)<\/a>/gi, function(_, label) {
      return '<a href="#" class="license-link" data-license="mit">' + label + '</a>';
    });
    var withCc0Anchor = withMitAnchor.replace(/Creative Commons 1\.0(\s*\(CC0\))?/gi, function(match) {
      return '<a href="#" class="license-link" data-license="cc0">' + match + '</a>';
    });
    return withCc0Anchor;
  }

  // Open a specific license modal based on the identifier requested by the user.
  // We fetch the source file lazily so embedded binaries stay in sync with
  // the repository licenses even when served offline.
  function openLicenseModal(code) {
    if (!code) return;
    var selector = '.license-modal[data-license="' + code + '"]';
    var modal = document.querySelector(selector);
    if (!modal) return;

    var body = modal.querySelector('[data-license-url]');
    if (body) {
      var loadedState = body.getAttribute('data-license-loaded');
      var loadingState = body.getAttribute('data-license-loading');
      if (loadedState !== 'true' && loadingState !== 'true') {
        var url = body.getAttribute('data-license-url');
        if (url) {
          body.textContent = 'Loading‚Ä¶';
          body.setAttribute('data-license-loading', 'true');

          var handleSuccess = function(text) {
            body.textContent = text;
            body.setAttribute('data-license-loaded', 'true');
            body.setAttribute('data-license-loading', 'false');
          };

          var handleError = function(err) {
            if (window.console && console.error) {
              console.error('Failed to load license text for', code, err);
            }
            body.textContent = 'Unable to load the license text. Please download it from the repository.';
            body.setAttribute('data-license-loaded', 'error');
            body.setAttribute('data-license-loading', 'false');
          };

          if (window.fetch) {
            fetch(url, { cache: 'no-store' })
              .then(function(resp) {
                if (!resp.ok) {
                  throw new Error('HTTP ' + resp.status);
                }
                return resp.text();
              })
              .then(handleSuccess)
              .catch(handleError);
          } else {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                  handleSuccess(xhr.responseText);
                } else {
                  handleError(new Error('HTTP ' + xhr.status));
                }
              }
            };
            xhr.onerror = function() { handleError(new Error('network error')); };
            xhr.send();
          }
        }
      }
    }

    modal.style.display = 'flex';
  }

  // Close the provided license modal so the overlay disappears cleanly.
  function closeLicenseModal(modal) {
    if (modal) {
      modal.style.display = 'none';
    }
  }

  // Example definitions stay in code so translations only supply human text.
  const apiExamples = [
    { key: 'root', method: 'api_method_get', methodFallback: 'GET', path: '/api', url: '/api' },
    { key: 'latest', method: 'api_method_get', methodFallback: 'GET', path: '/api/latest', url: '/api/latest?lat=35.6804&lon=139.7690&radius_m=1500&limit=20' },
    { key: 'tracks', method: 'api_method_get', methodFallback: 'GET', path: '/api/tracks', url: '/api/tracks?limit=25' },
    { key: 'track_index', method: 'api_method_get', methodFallback: 'GET', path: '/api/tracks/index/{number}', url: '/api/tracks/index/1' },
    { key: 'archive', method: 'api_method_get', methodFallback: 'GET', path: '/api/json/{frequency}.tgz', url: '/api/json/weekly.tgz' }
  ];

  // Build the localized API quickstart cards so the modal keeps site styling.
  function buildApiHTML() {
    var html = [];
    var intro = translate('api_intro');
    if (intro && intro !== 'api_intro') {
      html.push('<p class="api-intro">' + intro + '</p>');
    }
    var note = translate('api_examples_note');
    if (note && note !== 'api_examples_note') {
      html.push('<p class="api-note">' + note + '</p>');
    }
    var heading = translate('api_examples_heading');
    if (heading && heading !== 'api_examples_heading') {
      html.push('<h4 class="api-heading">' + heading + '</h4>');
    }
    html.push('<div class="api-grid">');
    apiExamples.forEach(function(example) {
      var title = translate('api_example_' + example.key + '_title');
      var desc = translate('api_example_' + example.key + '_desc');
      var linkText = translate('api_example_' + example.key + '_link');
      var noteText = translate('api_example_' + example.key + '_note');
      var methodLabel = translate(example.method);
      if (typeof methodLabel !== 'string' || methodLabel === example.method) {
        methodLabel = example.methodFallback;
      }
      html.push('<article class="api-card">');
      html.push('<div class="api-card-head">');
      html.push('<span class="api-method">' + methodLabel + '</span>');
      html.push('<span class="api-path">' + example.path + '</span>');
      html.push('</div>');
      if (title && title !== 'api_example_' + example.key + '_title') {
        html.push('<h5 class="api-card-title">' + title + '</h5>');
      }
      if (desc && desc !== 'api_example_' + example.key + '_desc') {
        html.push('<p class="api-card-desc">' + desc + '</p>');
      }
      if (linkText && linkText !== 'api_example_' + example.key + '_link') {
        html.push('<a class="api-card-link" href="' + example.url + '" target="_blank" rel="noopener">' + linkText + '</a>');
      }
      if (noteText && noteText !== 'api_example_' + example.key + '_note') {
        html.push('<p class="api-card-note">' + noteText + '</p>');
      }
      html.push('</article>');
    });
    html.push('</div>');
    var more = translate('api_more_docs');
    var moreLink = translate('api_more_docs_link_label');
    if (more && more !== 'api_more_docs') {
      var suffix = '';
      if (moreLink && moreLink !== 'api_more_docs_link_label') {
        suffix = ' <a href="/api/docs" target="_blank" rel="noopener">' + moreLink + '</a>';
      }
      html.push('<p class="api-more">' + more + suffix + '</p>');
    }
    return html.join('');
  }

  // Open modal with legal, source or license text
  function openInfoModal(topic) {
    if (window.__hideLegendHint) {
      window.__hideLegendHint();
    }
    if (topic === 'api') {
      var boxApi = document.getElementById('infoText');
      if (boxApi) {
        boxApi.innerHTML = buildApiHTML();
      }
      var headApi = document.getElementById('infoTitle');
      if (headApi) {
        headApi.textContent = translate('api_title');
      }
      var modalApi = document.getElementById('infoModal');
      if (modalApi) {
        modalApi.style.display = 'flex';
      }
      return;
    }
    var box = document.getElementById('infoText');
    var infoText = translate(topic + '_full');
    if (topic === 'legal' && typeof window.supportEmail === 'string' && window.supportEmail.trim() !== '') {
      infoText += '\n\n' + translate('legal_contact') + ' ' + window.supportEmail.trim();
    }
    if (topic === 'license') {
      infoText = decorateLicenseLinks(infoText);
    }
    if (box) box.innerHTML = buildInfoHTML(infoText);
    var head = document.getElementById('infoTitle');
    if (head) head.textContent = translate(topic + '_title');
    var modal = document.getElementById('infoModal');
    if (modal) modal.style.display = 'flex';
  }

  // Use event delegation because popups are created dynamically.
  document.addEventListener('click', function(ev) {
    // open legend modal when risk link clicked
    if (ev.target.classList.contains('risk-link')) {
      ev.preventDefault();
      openLegendModal();
    }
    if (ev.target.classList.contains('live-chart-link')) {
      ev.preventDefault();
      const dataset = ev.target.dataset;
      if (!dataset.device) return;
      const fallback = {
        device: dataset.device,
        name: dataset.name || '',
        transport: dataset.transport || '',
        tube: dataset.tube || '',
        country: dataset.country || '',
        lat: dataset.lat || '',
        lon: dataset.lon || '',
      };
      openLiveModal(dataset.device, fallback);
    }
    // switch to track view when track link clicked
    if (ev.target.classList.contains('track-link')) {
      ev.preventDefault();
      viewTrack(ev.target.dataset.track);
    }
    // open info modal for attribution links
    if (ev.target.classList.contains('attr-link')) {
      ev.preventDefault();
      openInfoModal(ev.target.dataset.info);
    }
    if (ev.target.classList.contains('license-link')) {
      ev.preventDefault();
      openLicenseModal(ev.target.dataset.license);
    }
  });

  (function(){
    var el = document.getElementById('legend');
    if (el) {
      el.addEventListener('click', openLegendModal);
    }

    // Unit toggle button
    var unitToggle = document.getElementById('unitToggle');
    if (unitToggle) {
      // Add tooltip
      attachControlTooltip(unitToggle, {
        placement: 'left',
        content: function () { return '¬µR/h ‚áÑ ¬µSv/h'; },
        maxWidth: 150,
      });

      // Add click handler
      unitToggle.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();

        // Toggle unit
        currentUnit = (currentUnit === 'uR') ? 'uSv' : 'uR';
        saveUnitPreference(currentUnit);

        // Update legend display
        updateLegendDisplay();

        // Refresh markers to show new units
        updateMarkers();

        // Update URL to reflect the new state
        updateUrl();
      });
    }

    // Close on backdrop click (UX nicety)
    var modal = document.getElementById('legendModal');
    if (modal) {
      modal.addEventListener('click', function(e){
        if (e.target === modal) modal.style.display = 'none';
      });
    }
    var infoModal = document.getElementById('infoModal');
    if (infoModal) {
      infoModal.addEventListener('click', function(e){
        if (e.target === infoModal) infoModal.style.display = 'none';
      });
    }
    var licenseModals = document.querySelectorAll('.license-modal');
    if (licenseModals && licenseModals.length) {
      for (var i = 0; i < licenseModals.length; i++) {
        (function(modalEl){
          modalEl.addEventListener('click', function(e){
            if (e.target === modalEl) closeLicenseModal(modalEl);
          });
        })(licenseModals[i]);
      }
    }
    var licenseCloseButtons = document.querySelectorAll('.license-modal-close');
    if (licenseCloseButtons && licenseCloseButtons.length) {
      for (var j = 0; j < licenseCloseButtons.length; j++) {
        (function(btn){
          btn.addEventListener('click', function(){
            var modalEl = btn;
            while (modalEl && (!modalEl.classList || !modalEl.classList.contains('license-modal'))) {
              modalEl = modalEl.parentNode;
            }
            closeLicenseModal(modalEl);
          });
        })(licenseCloseButtons[j]);
      }
    }
    var liveModal = document.getElementById('liveModal');
    if (liveModal) {
      liveModal.addEventListener('click', function(e){
        if (e.target === liveModal) hideLiveModal();
      });
    }
    var liveClose = document.getElementById('liveModalClose');
    if (liveClose) {
      liveClose.addEventListener('click', function(){ hideLiveModal(); });
    }

    // Spectrum modal event listeners
    var spectrumModal = document.getElementById('spectrumModal');
    if (spectrumModal) {
      spectrumModal.addEventListener('click', function(e){
        if (e.target === spectrumModal) hideSpectrumModal();
      });
    }
    var spectrumClose = document.getElementById('spectrumModalClose');
    if (spectrumClose) {
      spectrumClose.addEventListener('click', function(){ hideSpectrumModal(); });
    }

    // Initialize legend display with current unit preference
    updateLegendDisplay();
  })();
</script>
  </body>
</html>
